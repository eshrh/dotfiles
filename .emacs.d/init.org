---
title: Emacs Configuration
---
#+PROPERTY: header-args :tangle "init.el"
#+TITLE: My Emacs configuration
#+TOC: headlines 2

This is my literate init.el file. There are a lot of highly opinionated choices
here! My config is in a constant state of disrepair. If you’re reading this on
my website, then this is probably quite close to my current config since this
file is updated by the website’s build script.

* Internals
** Performance
Increase gc threshold. This is at the top of the file to ensure that
it benfits startup time of stuff later on.
#+BEGIN_SRC emacs-lisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
(setq gc-cons-threshold 100000000)
#+END_SRC

** Packages & Straight bootstrapping
I use [[https://github.com/raxod502/straight.el][straight.el]] for my package management. I find it to be much more flexible than
plain use-package or package.el. Also, it has much better portability and
version stability. Finally, I find its recipe-writing features very
nice, with the killer feature being clean support for forks, since I
fork emacs packages on a somewhat regular basis.

#+BEGIN_SRC emacs-lisp
(setq straight-check-for-modifications '(find-when-checking))
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
    (url-retrieve-synchronously
     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
     'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

straight-use-package is a bit of a keyful to type, especially interactively.
#+BEGIN_SRC emacs-lisp
(defalias 'sup 'straight-use-package)
#+END_SRC

** JIT
I use a custom compiled version of emacs with native compilation enabled. The
first line enabled deferred comp so that elisp is compiled async when its first
called. The second line is so that I don’t see annoying popups every time.
#+BEGIN_SRC emacs-lisp
(setq comp-deferred-compilation t)
(setq warning-suppress-log-types '((comp)))
#+END_SRC

** Macros
Some macros that are used in this file:
*** Better hooks
Hook to add multiple functions and forms to a hook. This accepts any
number of arguments where the first is the (quoted) hook itself, and
each element is either an unquoted symbol, in which its treated as a
function, or a form in which case it is inserted directly.
#+BEGIN_SRC emacs-lisp
(defmacro add-fs-to-hook (hook &rest funcs)
  "Add functions to hook. A function is either an unquoted token, or a form.
If it's a token, then its treated as a function and enabled. Otherwise, the form is run."
  `(add-hook ,hook
             (fn ,@(mapcar (lambda (el)
                             (if (listp el)
                                 el
                               (list el 1)))
                           funcs))))
#+END_SRC

Sometimes its helpful to think about adding a single function to many
hooks. Everything should be quoted here.
#+BEGIN_SRC emacs-lisp
(defmacro add-to-hooks (f &rest hooks)
  "Add a single function to many quoted hooks"
  `(progn ,@(mapcar (lambda (hook)
                      `(add-hook ,hook ,f))
                    hooks)))
#+END_SRC

*** Nullary lambda
#+BEGIN_SRC emacs-lisp
(defmacro fn (&rest forms)
  (declare (indent 0))
  `(lambda () ,@forms))
#+END_SRC

** Libraries
Classic libraries I use regularly.
+ s :: good string manipulation
+ dash :: functional programming essentials like threading and
  recursive style list manipulation
#+BEGIN_SRC emacs-lisp
(sup 's)
(sup 'dash)
#+END_SRC

** Make C-h backspace
Too used to readline, make C-h backspace and C-x h help.

#+BEGIN_SRC emacs-lisp
(global-set-key [?\C-h] 'delete-backward-char)
(global-set-key [?\C-x ?h] 'help-command)
#+END_SRC

* Visual configuration
** Disable bell
I don’t know who thought it was a good idea to include this.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Disable UI bloat
Turn off the menu-bar, tool-bar, an scroll-bar. I hate bars!

The tool bar and the menu bar can be turned off by calling their
functions with the ~-1~ argument of course, but doing it this way shaves
off actually a significant amount of time from startup. I don't
(anymore) run emacs in a daemon, so startup time is somewhat valuable
to me.

#+BEGIN_SRC emacs-lisp
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)
(scroll-bar-mode -1)
#+END_SRC

** Better parenthesis location

I can’t count parentheses. I use an advice override to change how the parenthesis
locating functionality works. This is because I use a block cursor with meow,
which makes cursor position slightly deceptive.

Basically, the block cursor by default highlights the parenthesis when
your cursor is immediately AFTER the parenthesis in question, because
the point is always between two characters in emacs (the point is
really right after the parenthesis as well). So, if you have nested
parentheses, as we often do, it's strange to see the "wrong
parenthesis" highlighted.

This advice first checks before the point and only then after the
point for a parenthesis. I think this behavior is very intuitive. The
defined function overrides the internal function used to find parentheses.

#+BEGIN_SRC emacs-lisp
(column-number-mode)
(show-paren-mode)
(defun show-paren--locate-near-paren-ad ()
  "Locate an unescaped paren \"near\" point to show.
If one is found, return the cons (DIR . OUTSIDE), where DIR is 1
for an open paren, -1 for a close paren, and OUTSIDE is the buffer
position of the outside of the paren.  Otherwise return nil."
  (let* ((before (show-paren--categorize-paren (point))))
    (when (or
       (eq (car before) 1)
       (eq (car before) -1))
      before)))

(advice-add 'show-paren--locate-near-paren
            :override #'show-paren--locate-near-paren-ad)
#+END_SRC

** Colorize color strings.
#+BEGIN_SRC emacs-lisp
(sup 'rainbow-mode)
(add-hook 'prog-mode #'rainbow-mode)
#+END_SRC

** Highlight current line
I find this very helpful not only to quickly locate the cursor, but to
read code in general. It helps me focus, especially when stepping
through code line by line.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

** Auto whitespace cleanup
Couldn't be bothered to care about whitespace myself. Didn't we make
computers to do repetitive stuff for us??
#+BEGIN_SRC emacs-lisp
(add-fs-to-hook 'prog-mode-hook
                (add-hook 'after-save-hook
                          (fn (whitespace-cleanup))))
#+END_SRC

** Fonts
My default fonts. Iosevka Meiseki is a customized version of [[https://github.com/be5invis/iosevka][iosevka]]
font. You can find a copy of it on my website, somewhere, probably
(maybe the about page).
#+BEGIN_SRC emacs-lisp
(defvar emacs-english-font "Iosevka Meiseki Sans")
(defvar emacs-cjk-font "IPAGothic")
(setq my-font (concat emacs-english-font "-12"))

(add-to-list 'default-frame-alist `(font . ,my-font))
(set-face-attribute 'default t :font my-font)
#+END_SRC

** Theme
I've tried countless other themes, but somehow I just keep coming back
to gruvbox. I switch between ~gruvbox-light-hard~ and ~gruvbox-dark-hard~
fairly often though, both are nice. I'm a big fan of the dark
version's warm and retro-y feel, its visually distinct and comfy.

#+BEGIN_SRC emacs-lisp
(sup 'gruvbox-theme)
(load-theme 'gruvbox-dark-hard t nil)
#+END_SRC

** Frame
Make the title look better so that my status bar can print it nicely
for the rice screenshots. ~%b~ is substituted for the name of the
currently active buffer.
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("emacs: %b"))
#+END_SRC

** Modeline
I've liked smart-mode-line in the past, but I prefer telephone line's
modularity, design, and visual appeal right now.

#+BEGIN_SRC emacs-lisp
(sup 'telephone-line)
#+END_SRC

Use a neat cubic curved shape to separate segments. The last line with
~evil-use-short-tag~ makes telephone-line's meow segment, which I wrote
and upstreamed, use single letters to show meow state instead of the
whole word, so like "N" instead of "NORMAL".
#+BEGIN_SRC emacs-lisp
(require 'telephone-line)
(setq telephone-line-primary-left-separator 'telephone-line-cubed-left
      telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
      telephone-line-primary-right-separator 'telephone-line-cubed-right
      telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)

(setq telephone-line-height 24
      telephone-line-evil-use-short-tag t)
#+END_SRC

*** Custom segments
One of the big reasons I like telephone line is the absolute ease of
defining new segments that look nice as hell.

#+BEGIN_SRC emacs-lisp
(telephone-line-defsegment* telephone-line-simpler-major-mode-segment ()
  (concat "["
          (if (listp mode-name)
              (car mode-name)
            mode-name) "]"))
#+END_SRC

This segment is a simpler indicator of position. I don't use line
numbers on the side of my screen, so it's pretty neccessary for me to
quickly parse my position at a glance. Column numbers are on the left
since they change more often, and this segment is the leftmost element
on the right side of my bar. This means that there's no unnecessary
movement.

#+BEGIN_SRC emacs-lisp
(telephone-line-defsegment* telephone-line-simple-pos-segment ()
  (concat "%c : " "%l/" (number-to-string (count-lines (point-min) (point-max))) ))
#+END_SRC

*** Segment setup
#+BEGIN_SRC emacs-lisp
(setq telephone-line-lhs
      '((nil . (telephone-line-projectile-buffer-segment))
        (accent . (telephone-line-simpler-major-mode-segment))
        (nil . (telephone-line-meow-tag-segment
                telephone-line-misc-info-segment)))
      telephone-line-rhs
      '((nil . (telephone-line-simple-pos-segment))
        (accent . (telephone-line-buffer-modified-segment))))

(telephone-line-mode 1)
#+END_SRC

** Pixel scrolling
New feature in Emacs 29! Do try it out, it's really quite neat. this
function only activates when possible.
#+BEGIN_SRC emacs-lisp
(defun pixel-scroll-setup ()
  (interactive)
  (setq pixel-scroll-precision-large-scroll-height 30.0)
  (setq pixel-scroll-precision-interpolation-factor 30))

(when (boundp 'pixel-scroll-precision-mode)
  (pixel-scroll-setup)
  (add-hook 'prog-mode-hook #'pixel-scroll-precision-mode)
  (add-hook 'org-mode-hook #'pixel-scroll-precision-mode))
#+END_SRC

* Packages
** Nyaatouch
Nyaatouch is my personal modal editing system. It is highly optimized for the
dvorak keyboard and is built on meow (hence the name).

#+BEGIN_SRC emacs-lisp
(sup '(nyaatouch
       :repo "https://github.com/eshrh/nyaatouch"
       :fetcher github))
(require 'nyaatouch)
(turn-on-nyaatouch)


#+END_SRC

Nyaatouch brings in some packages as dependencies: avy, swiper, meow,
smartparens. You can find more information about it at the repo.
I really don't want to add vterm as a dependency of nyaatouch, but I
use it a lot and want it on my leader in a convenient location.
#+BEGIN_SRC emacs-lisp
(meow-leader-define-key
 '("d" . vterm-toggle-cd))
#+END_SRC

Some ideas in nyaatouch spend some time in incubation in my personal
config before I spin them off there. One of those is a key for
deleting a single character

#+BEGIN_SRC emacs-lisp
(meow-normal-define-key '("r" . meow-delete))
#+END_SRC

Add a character for the fill-paragraph command
#+BEGIN_SRC emacs-lisp
(meow-normal-define-key
 '("`" . fill-paragraph))
#+END_SRC

Make sure the esc key in the terminal key never acts as meta.
#+BEGIN_SRC emacs-lisp
(unless (display-graphic-p)
  (setq meow-esc-delay 0))
#+END_SRC


** Undo-tree
Better undo for emacs. I really enjoy the tree visualization feature
this package adds. If you haven't checked it out, try pressing ~C-x u~!
#+BEGIN_SRC emacs-lisp
(sup 'undo-tree)
(global-undo-tree-mode)
(setq undo-tree-auto-save-history nil)
#+END_SRC

** Ace-window
Ace-window is super nice because it lets you quickly switch to a window
when you have >2 open by providing a letter hint.
#+BEGIN_SRC emacs-lisp
(sup 'ace-window)
(global-set-key [remap other-window] 'ace-window)
#+END_SRC

I add some extra config for myself.
#+BEGIN_SRC emacs-lisp
(setq aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s)) ;; dvorak moment
(setq aw-scope 'frame) ;; don't hint me for things outside the frame
(setq aw-background nil) ;; don't change the buffer background
(setq aw-ignore-current t) ;; i never want to select the current buffer
#+END_SRC

** Dashboard
An essential component of any
emacs-window-with-neofetch-and-tiling-wm-and-anime-girl-wp screenshot.
#+BEGIN_SRC emacs-lisp
(sup 'dashboard)
(dashboard-setup-startup-hook)
#+END_SRC

Startup to the dashboard
#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice (get-buffer "*dashboard*"))
#+END_SRC

Self explanatory config
#+BEGIN_SRC emacs-lisp
(setq dashboard-center-content t)
(setq dashboard-show-shortcuts nil)
(setq dashboard-set-init-info nil) ;; don't show me that sad stuff...
(setq dashboard-set-footer nil)
#+END_SRC

Declutter the items shown on the dashboard
#+BEGIN_SRC emacs-lisp
(setq dashboard-items '((recents  . 5)
                        (projects . 5)
                        (agenda . 5)))
(setq dashboard-agenda-sort-strategy '(time-up))
(setq dashboard-item-names '(("Recent Files:" . "recent:")
                             ("Projects:" . "projects:")
                             ("Agenda for the coming week:" . "agenda:")))
#+END_SRC

Nice image and nice title. If we're in the terminal, display an ASCII gnu
instead.
#+BEGIN_SRC emacs-lisp
(setq dashboard-banner-logo-title "GNU emacsへようこそ。")

(defmacro set-dashboard-banner (name)
  `(setq dashboard-startup-banner
         (expand-file-name ,name user-emacs-directory)))
(if (or (display-graphic-p) (daemonp))
    (set-dashboard-banner "hiten_render_rsz.png")
  (set-dashboard-banner "gnu.txt"))
#+END_SRC

This is an important line because in order for dashboard to produce the org
agenda, every org file needs to be opened, which means your recent list is
just cluttered.
#+BEGIN_SRC emacs-lisp
(add-to-list 'recentf-exclude
             (concat (getenv "HOME") "/org"))
#+END_SRC

** Company
The one true autocompleter! Company mode takes a bit to startup, so defer.
#+BEGIN_SRC emacs-lisp
(sup 'company)
(add-hook 'after-init-hook #'global-company-mode)
(sup 'company-ctags)
#+END_SRC

** Projectile
Project-aware emacs commands.
#+BEGIN_SRC emacs-lisp
(sup 'projectile)
(projectile-mode +1)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC

The main feature I use from projectile is it's awesome fuzzy search for files
across your entire project. I use this so much that I use it as my default
find file function, only when I'm in a project.
#+BEGIN_SRC emacs-lisp
(defun find-file-or-projectile ()
  (interactive)
  (if (projectile-project-p)
      (call-interactively 'projectile-find-file)
    (call-interactively 'find-file)))

(global-set-key (kbd "C-x C-f") 'find-file-or-projectile)
;; just in case i need to use standard find file, probably to make a file.
(meow-leader-define-key '("U" . find-file))
#+END_SRC

** Searching
*** Ivy
I currently use ivy for completions. I’ve used selectrum and vertico in the
past, but ivy is better in my opinion simply because so many packages have built
in integrations with it. I also use swiper extensively.

#+BEGIN_SRC emacs-lisp
(sup 'ivy)
(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
#+END_SRC

Typing things over and over again is hard. Prescient keeps track of command
history and makes recent commands appear higher up.

#+BEGIN_SRC emacs-lisp
(sup 'prescient)
(sup 'ivy-prescient)
(ivy-prescient-mode)
#+END_SRC

*** Marginalia
An essential addition to the completing-read buffer that offers a bit of
documentation to entries.
#+BEGIN_SRC emacs-lisp
(sup 'marginalia)
(marginalia-mode)
#+END_SRC

*** Posframe
In GUI mode, I like to have all completing-read queries come up in a new frame
in the middle of my screen. Posframe does this with a child frame. I like how it
looks. However, I don't want org-ref or swiper in the middle, so I add exceptions.

#+BEGIN_SRC emacs-lisp
(sup 'posframe)
(sup 'ivy-posframe)

(setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))

(setq ivy-posframe-display-functions-alist
      '((swiper          . ivy-display-function-fallback)
        (org-ref-insert-link . ivy-display-function-fallback)
        (t               . ivy-posframe-display)))

(ivy-posframe-mode 1)
#+END_SRC

** Helpful
Better describe* functions that have more information and look neater.
#+BEGIN_SRC emacs-lisp
(sup 'helpful)
#+END_SRC

Override keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x h C-f") #'helpful-callable)
(global-set-key (kbd "C-x h C-v") #'helpful-variable)
(global-set-key (kbd "C-x h C-k") #'helpful-key)
(global-set-key (kbd "C-x h f") #'helpful-callable)
(global-set-key (kbd "C-x h v") #'helpful-variable)
(global-set-key (kbd "C-x h k") #'helpful-key)
#+END_SRC

** Japanese-related
Sdcv lets you use dictionaries right from emacs.

I do some hostname checking because chances are, if I'm on a new computer then I
probably

1. Don't have sdcv installed
2. Don't have any dictionaries
3. Don't want to read japanese
#+BEGIN_SRC emacs-lisp
(sup '(sdcv2 :type git
             :repo "https://github.com/manateelazycat/sdcv"
             :files ("sdcv.el")))

(cond ((string= (system-name) "himawari")
       (progn
         (setq sdcv-dictionary-simple-list '("jmdict-ja-en"))
         (setq sdcv-dictionary-complete-list '("jmdict-ja-en"
                                               "J_PLACES"))))
      ((string= (system-name) "shiragiku")
       (progn
         (setq sdcv-dictionary-simple-list '("JMdict_e"))
         (setq sdcv-dictionary-complete-list '("daijisen.tab" "JMdict_e")))))

(setq sdcv-dictionary-data-dir "/usr/share/stardict/dic/")
(setq sdcv-env-lang "ja_JP.UTF-8")
#+END_SRC

*** Mecab
This requires mecab to be installed on your system, as well as a dictionary for
it. This is a library-style package that exposes a japanese tokenizer. I use it
for easy lookups.

#+BEGIN_SRC emacs-lisp
;; TODO Add yomenai.el code here.
(if (executable-find "mecab")
    (sup '(mecab :type git
                 :repo "https://github.com/syohex/emacs-mecab"
                 :pre-build ("make")
                 :files ("mecab-core.so"
                         "mecab-core.o"
                         "mecab-core.c"
                         "mecab.el"))))
#+END_SRC

*** Reading books
Nov-mode is an excellent epub reader. It's very soulful to read books in emacs.
#+BEGIN_SRC emacs-lisp
(sup 'nov)
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
(setq nov-text-width 100)
#+END_SRC

** Music

Emms is the emacs multimedia system. I'm not going to lie, I perpetually feel
like I'm using 5% of this package. I really only use it to control MPD, which
feels like a second-class usecase for this package. I'm really considering
writing my own elisp mpd client.

#+BEGIN_SRC emacs-lisp
(sup 'emms)
(require 'emms-setup)
(require 'emms-source-file)
(require 'emms-source-playlist)
(require 'emms-playlist-mode)
(require 'emms-browser)
(require 'emms-info)
(require 'emms-info-native)
(setq emms-playlist-default-major-mode #'emms-playlist-mode)
(add-to-list 'emms-track-initialize-functions #'emms-info-initialize-track)
(setq emms-info-functions '(emms-info-native))
(setq emms-track-description-function #'emms-info-track-description)
(add-fs-to-hook 'emms-browser-mode-hook (when (fboundp 'emms-cache)
                                          (emms-cache 1)))
#+END_SRC

Bind tab in the music browser to collapse and expand artist subtrees
#+BEGIN_SRC emacs-lisp
(define-key emms-browser-mode-map (kbd "<tab>") 'emms-browser-toggle-subitems)
#+END_SRC

*** EMMS browser tree structure
There is currently a bug in emms that makes it unable to parse mpd
albumartist tags. A patch by Pavel Korytov has been accepted upstream,
but it hasn’t made it to me yet.

#+BEGIN_SRC emacs-lisp
(defun emms-info-mpd-process-with-aa (track info)
  (dolist (data info)
    (let ((name (car data))
          (value (cdr data)))
      (setq name (cond ((string= name "artist") 'info-artist)
                       ((string= name "albumartist") 'info-albumartist)
                       ((string= name "composer") 'info-composer)
                       ((string= name "performer") 'info-performer)
                       ((string= name "title") 'info-title)
                       ((string= name "album") 'info-album)
                       ((string= name "track") 'info-tracknumber)
                       ((string= name "disc") 'info-discnumber)
                       ((string= name "date") 'info-year)
                       ((string= name "genre") 'info-genre)
                       ((string= name "time")
                        (setq value (string-to-number value))
                        'info-playing-time)
                       (t nil)))
      (when name
        (emms-track-set track name value)))))
#+END_SRC

*** MPD integration setup
I don't want to set up mpd (which takes some time) on startup since I might not
be using emacs for music every time i start it. This function thus only runs
when I actually open the music browser.
#+BEGIN_SRC emacs-lisp
(defun emms-mpd-setup ()
  (require 'emms-player-mpd)
  (setq emms-player-list '(emms-player-mpd))
  (add-to-list 'emms-info-functions 'emms-info-mpd)
  (add-to-list 'emms-player-list 'emms-player-mpd)
  (setq emms-player-mpd-server-name "localhost")
  (setq emms-player-mpd-server-port "6600")
  (setq emms-player-mpd-music-directory "~/mus")
  (advice-add 'emms-info-mpd-process :override 'emms-info-mpd-process-with-aa)
  (emms-player-mpd-connect))

(add-hook 'emms-browser-mode-hook #'emms-mpd-setup)
(add-hook 'emms-playlist-cleared-hook #'emms-player-mpd-clear)
#+END_SRC

** Highlights
*** Lisp highlighting
Install a bunch of Fanael’s visual packages to make lisp source editing much
nicer.
+ highlight-defined: highlight known symbols instead of just the built in ones
+ highlight-numbers: numbers
+ highlight-delimiters: highlight brackets and parens nicely
+ highlight-quoted: highlight quoted symbols in a different color
  [applies only to elisp]

I really do find these pretty essential for comfortable lisp
programming, but maybe just because I'm so used to them.
#+BEGIN_SRC emacs-lisp
(sup 'highlight-defined)
(sup 'highlight-numbers)
(sup 'rainbow-delimiters)
(sup 'highlight-quoted)
(defun highlight-lisp-things-generic ()
  (highlight-numbers-mode)
  (highlight-defined-mode)
  (rainbow-delimiters-mode))

(add-hook 'emacs-lisp-mode-hook #'highlight-quoted-mode)
(add-to-hooks #'highlight-lisp-things-generic 'lisp-data-mode-hook 'clojure-mode-hook)
#+END_SRC

*** Highlight todos
#+BEGIN_SRC emacs-lisp
(sup 'hl-todo)
(global-hl-todo-mode)
#+END_SRC

** Which-key
There are too many emacs keybindings and life is too short.
#+BEGIN_SRC emacs-lisp
(sup 'which-key)
(which-key-mode)
#+END_SRC

** Format-all
All-purpose code formatter for when things break
#+BEGIN_SRC emacs-lisp
(sup 'format-all)
#+END_SRC

** Terminal and shell config
Undoubtedly the best terminal in emacs. Depends on the module libvterm, which
means your emacs has to be compiled with module support enabled (damn you
Ubuntu!!).

#+BEGIN_SRC emacs-lisp
(sup 'vterm)
(sup 'fish-mode)
#+END_SRC

*** Config
Make hl-line-mode turn off in vterm-mode.
#+BEGIN_SRC emacs-lisp
(add-fs-to-hook 'vterm-mode-hook (setq-local global-hl-line-mode
                                             (null global-hl-line-mode)))


#+END_SRC

Kill the buffer when ~C-d~ is pressed to exit the shell.
#+BEGIN_SRC emacs-lisp
(setq vterm-kill-buffer-on-exit t)
(setq vterm-buffer-name-string "vt//%s")
#+END_SRC

Start vterm mode in the insert meow state.
#+BEGIN_SRC emacs-lisp
(add-to-list 'meow-mode-state-list '(vterm-mode . insert))
#+END_SRC

*** Vterm-toggle
Toggles a window with a re-usable vterm. Good for reducing buffer clutter.

#+BEGIN_SRC emacs-lisp
(sup 'vterm-toggle)
(setq vterm-toggle-hide-method 'delete-window)
(setq vterm-toggle-fullscreen-p nil)
(add-to-list 'display-buffer-alist
             '((lambda (bufname _)
                 (with-current-buffer bufname (equal major-mode 'vterm-mode)))
                (display-buffer-reuse-window display-buffer-at-bottom)
                (dedicated . t)
                (reusable-frames . visible)
                (window-height . 0.4)))
#+END_SRC

*** Kill vterm buffer and window
#+BEGIN_SRC emacs-lisp
(defun vterm--kill-vterm-buffer-and-window (process event)
  "Kill buffer and window on vterm process termination."
  (when (not (process-live-p process))
    (let ((buf (process-buffer process)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (kill-buffer)
          (ignore-errors (delete-window))
          (message "VTerm closed."))))))

(add-fs-to-hook 'vterm-mode-hook
                (set-process-sentinel (get-buffer-process (buffer-name))
                                      #'vterm--kill-vterm-buffer-and-window))
#+END_SRC

** Org-mode
#+BEGIN_SRC emacs-lisp
(sup 'org)
#+END_SRC

Path configuration. I use a directory called org in my home directory to store
my org files.
#+BEGIN_SRC emacs-lisp
(when (file-exists-p "~/org/")
  (setq org-directory "~/org/")
  (setq org-agenda-files '("~/org/")))
#+END_SRC

Allow lists like a) b) c)
#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

Enable and disable some modes on opening an org buffer
+ Indent-mode means that star headings are hidden and hierarchy is
  whitespace-based
+ Turn off electrict quote completion because it makes typing elisp quotes annoying.
+ Turn on auto-fill mode to prevent lines from getting too long.
#+BEGIN_SRC emacs-lisp
(add-fs-to-hook 'org-mode-hook
                org-indent-mode
                (electric-quote-mode -1)
                auto-fill-mode)

#+END_SRC

Don't insert lines in between headers and list items.
#+BEGIN_SRC emacs-lisp
(setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
#+END_SRC

Change the backends.
#+BEGIN_SRC emacs-lisp
(sup 'ox-pandoc)
(setq org-export-backends '(latex beamer md html odt ascii org-ref pandoc))
#+END_SRC

Don't indent code in org-babel
#+BEGIN_SRC emacs-lisp
(setq org-edit-src-content-indentation 0)
#+END_SRC

Even emacs can’t make me not procrastinate!
#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 2)
#+END_SRC

Babel src setup
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-confirm-babel-evaluate nil
      org-src-preserve-indentation t)
#+END_SRC


*** Org-fragtog
A neat little package to render latex fragments as you write them.
#+BEGIN_SRC emacs-lisp
(sup 'org-fragtog)
#+END_SRC

Quick function to disable fragtogging while in a table
#+BEGIN_SRC emacs-lisp
(defun org-inside-latex-block ()
  (eq (nth 0 (org-element-at-point)) 'latex-environment))
(setq org-fragtog-ignore-predicates '(org-at-table-p org-inside-latex-block))
#+END_SRC

*** Org-ref
Cool package to deal with citations in org. Especially nice when writing latex
in org-mode.

My typical workflow involves importing papers into [[https://www.zotero.org/][zotero]], which will
automatically update a system-wide bibliography file stored in bibtex thanks to
the [[https://retorque.re/zotero-better-bibtex/][better bibtex]] extension, which is essential.

#+BEGIN_SRC emacs-lisp
(sup 'org-ref)
(sup 'ivy-bibtex)
(require 'org-ref-ivy) ; ivy integration

(setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body
      org-ref-insert-cite-function 'org-ref-cite-insert-ivy
      org-ref-insert-label-function 'org-ref-insert-label-link
      org-ref-insert-ref-function 'org-ref-insert-ref-link
      org-ref-cite-onclick-function (lambda (_) (org-ref-citation-hydra/body)))

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)
  (define-key org-mode-map (kbd "S-]") 'org-ref-insert-link-hydra/body)
  (define-key org-mode-map (kbd "C-c r") 'org-ref-citation-hydra/body))
(setq bibtex-completion-bibliography '("~/docs/library.bib"))
(setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
#+END_SRC

*** Org-roam
#+BEGIN_SRC emacs-lisp
(sup 'org-roam)
(setq org-roam-v2-ack t)
#+END_SRC

Basic setup. ~org-roam-db-autosync-mode~ is nice, but adds about 1.5s to my
startup time. Not good!

#+BEGIN_SRC emacs-lisp
(unless (file-directory-p "~/roam")
  (make-directory "~/roam"))
(setq org-roam-directory (file-truename "~/roam"))

#+END_SRC

Pressing enter while your point is on a link should follow the link.
#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

Keybindings for my most used roam actions. ~publish.el~ refers to a personal
elisp file I use to generate a website from my roam files you can find [[https://notes.esrh.me][here!]]
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c c i") #'org-roam-node-insert)
(global-set-key (kbd "C-c c f") #'org-roam-node-find)
(global-set-key (kbd "C-c c s") #'org-roam-db-sync)
(global-set-key (kbd "C-c c p") (fn (interactive) (load-file "~/roam/publish.el")))

#+END_SRC

The default file name looks ugly and leads to ugly urls once exported. This
makes the filenames just the titles.
#+BEGIN_SRC emacs-lisp
(setq org-roam-capture-templates
      '(("d" "default" plain "%?" :target
         (file+head "${slug}.org" "#+title: ${title}\n")
         :unnarrowed t)))
#+END_SRC

*** Anki integration
Anki-editor lets you push notes to [[https://apps.ankiweb.net/][anki]] from emacs. My most common use case for
this is to quickly write up some property list in the from ~- key :: value~ and
then use this quick function to transform an entry into an anki card that can
then be pushed with anki editor with ~anki-editor-push-notes~.

I'm sorry this function depends on a snippet that may or may not be available to
you wherever you are reading this. I plan to improve the code soon.

#+BEGIN_SRC emacs-lisp
(sup 'anki-editor)
;; TODO improve this code!!!
(defun anki-description-transform ()
  (interactive)
  (let* ((begin (re-search-backward "^-"))
         (end (forward-sentence))
         (raw (buffer-substring-no-properties
               begin
               end))
         (split (s-split "::" raw))
         (q (substring (s-trim (car split)) 2))
         (a (s-trim (cadr split)))
         (depth (org-current-level)))
    (yas-expand-snippet
     (yas-lookup-snippet "anki-editor card")
     begin end)
    (insert q)
    (yas-next-field-or-maybe-expand)
    (insert a)
    (yas-end)
    (org-backward-element)))
#+END_SRC

*** Latex
Adds my favorite document class, IEEE transactions to the org latex export.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("IEEEtran"
                 "\\documentclass{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))

#+END_SRC

** IRC
I store some IRC secrets outside of dotfile version control.

#+BEGIN_SRC emacs-lisp
(setq erc-default-server "irc.libera.chat")

(add-hook 'erc-before-connect (lambda (SERVER PORT NICK)
                                (when (file-exists-p "ircconfig.elc")
                                  (load
                                   (expand-file-name
                                    "ircconfig"
                                    user-emacs-directory)))))
#+END_SRC

** YASnippet
Just works!
#+BEGIN_SRC emacs-lisp
(sup 'yasnippet)
(yas-global-mode)
(setq yas-indent-line 'fixed)
#+END_SRC

** Flycheck
Classic linter framework
#+BEGIN_SRC emacs-lisp
(sup 'flycheck)
#+END_SRC

** Magit
Nothing to be said here
#+BEGIN_SRC emacs-lisp
(sup 'magit)
#+END_SRC

Ediff makes dealing with merging conflicts extremely comfortable. I make some
quick changes to how it lays out merge windows.
#+BEGIN_SRC emacs-lisp
(setq ediff-diff-options "")
(setq ediff-custom-diff-options "-u")
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq ediff-split-window-function 'split-window-vertically)
#+END_SRC

** EAF
EAF is a really cool project to bring advanced GUI capability to emacs. These
requires cost pretty much nothing on my PC, so i might as well include them.
#+BEGIN_SRC emacs-lisp
(when (file-directory-p (concat
                         user-emacs-directory
                         "site-lisp/emacs-application-framework/"))
  (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
  (require 'eaf)
  (require 'eaf-org-previewer)
  (require 'eaf-browser)
  (require 'eaf-image-viewer))
#+END_SRC

Some EAF apps steal the SPC key which leaves me helpless without my meow leader.
#+BEGIN_SRC emacs-lisp
(add-fs-to-hook 'eaf-mode-hook (define-key eaf-mode-map (kbd "SPC") 'meow-keypad))
#+END_SRC

** Ligatures and symbols
Prettify symbols is emacs' built in method for symbol replacment. Any
string of any length can be replaced by a character. The
prettify-symbols-alist is buffer local, so it can be modified via hook.
#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode)
(add-fs-to-hook 'emacs-lisp-mode-hook
                (push '("fn" . ?∅) prettify-symbols-alist))
#+END_SRC

My font uses ligatures. Ligature.el adds support for this on emacs 28+
compiled with harfbuzz and cairo.

#+BEGIN_SRC emacs-lisp
(sup '(ligature
       :type git
       :repo "https://github.com/mickeynp/ligature.el"))
(ligature-set-ligatures
 'prog-mode
 '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
   ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
   "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
   "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
   "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
   "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
   "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
   "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
   ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
   "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
   "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
   "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
   "\\\\" "://"))
(global-ligature-mode)
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
(sup 'lsp-mode)
(sup 'lsp-ui)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(sup 'lsp-haskell)
#+END_SRC

Don't ask for project root config when opening files
#+BEGIN_SRC emacs-lisp
(setq lsp-auto-guess-root t)
#+END_SRC

Debloat the UI
#+BEGIN_SRC emacs-lisp
(setq lsp-enable-symbol-highlighting nil)
(setq lsp-lens-enable nil)
(setq lsp-headerline-breadcrumb-enable nil)
#+END_SRC

Turn on the lsp by default for some languages only.
#+BEGIN_SRC emacs-lisp
(add-to-hooks #'lsp-deferred 'python-mode-hook 'haskell-mode-hook 'c-mode-hook)
#+END_SRC

** Language-specific config
*** Java
Meghanada has better integration with emacs than the lsps i've tried.
#+BEGIN_SRC emacs-lisp
(sup 'meghanada)
(add-fs-to-hook 'java-mode-hook
                meghanada-mode
                flycheck-mode
                (setq c-basic-offset 4)
                (setq tab-width 4))
#+END_SRC

*** Haskell
Interactive haskell mode lets you use the nice repl with ~C-c C-z~
#+BEGIN_SRC emacs-lisp
(sup 'haskell-mode)
(add-hook 'haskell-mode-hook #'interactive-haskell-mode)
#+END_SRC

Interactive haskell error customization
#+BEGIN_SRC emacs-lisp
(setq haskell-interactive-popup-errors t)
#+END_SRC

*** C++
#+BEGIN_SRC emacs-lisp
(setq-default
              c-basic-offset 4
              kill-whole-line t
              indent-tabs-mode nil)
#+END_SRC

*** Lisp
The best common lisp ide!
#+BEGIN_SRC emacs-lisp
(sup 'slime)
(setq inferior-lisp-program "sbcl")
(sup 'slime-company)
(add-fs-to-hook 'common-lisp-mode-hook (slime-setup '(slime-fancy slime-company)))
(add-hook 'lisp-mode-hook #'flycheck-mode)
#+END_SRC


**** Smartparens
#+BEGIN_SRC emacs-lisp
(smartparens-global-mode)
#+END_SRC

Define a function to disable auto quote-completion. This is
annoying in lisplike languages.

#+BEGIN_SRC emacs-lisp
(defun sp-disable (mode str)
  (sp-local-pair mode str nil :actions nil))
#+END_SRC

Disable single quote pairing in lisp-data modes
#+BEGIN_SRC emacs-lisp
(sp-disable 'lisp-data-mode "'")
#+END_SRC

**** Elisp
#+BEGIN_SRC emacs-lisp
(sup 'elisp-format)
(setq elisp-format-column 80)
(sp-disable 'emacs-lisp-mode "'")
(sp-disable 'emacs-lisp-mode "`")
(sp-disable 'org-mode "'")
#+END_SRC

**** Aggressive indenting
Keeps code indented no matter what. This package is extremely broken
for most block based languages, but works like a charm for lisps.
#+BEGIN_SRC emacs-lisp
(sup 'aggressive-indent-mode)
(add-hook 'lisp-data-mode-hook #'aggressive-indent-mode 1)
#+END_SRC

*** TeX
AuCTeX offers a lot of sweet features that I’ve come to take for granted
#+BEGIN_SRC emacs-lisp
(sup 'auctex)
#+END_SRC

Use [[https://sioyek.info/][sioyek]] to view pdfs compiled with tex. Sioyek has some rough edges
to be sure, but it also has really cute features centered around
technical material.

I also include some fallbacks in order of my preference.

In order to add a custom tex viewing program, it must have an entry in
TeX-view-program-list that uses some expansion tokens that you're free
to copy from here. Some day, TODO, I'd like to get this upstreamed to
emacs, I do believe that sioyek is sufficiently popular.

#+BEGIN_SRC emacs-lisp
(setq my-pdf-viewer (-first #'executable-find
                            '("sioyek" "evince" "okular" "zathura" "firefox")))

(setq TeX-view-program-list nil)
(add-to-list
 'TeX-view-program-list
 `("sioyek" ("sioyek %o" (mode-io-correlate
                          ,(concat
                            " --reuse-instance"
                            " --forward-search-file \"%b\""
                            " --forward-search-line %n"
                            " --inverse-search \"emacsclient +%2 %1\"")))
   "sioyek"))

(add-fs-to-hook 'LaTeX-mode-hook
                (setq TeX-view-program-selection
                      `((output-pdf ,my-pdf-viewer)
                        (output-dvi ,my-pdf-viewer)
                        (output-html "xdg-open")))
                auto-fill-mode)
#+END_SRC

Reftex integration
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook #'turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)
#+END_SRC

Make <tab> cycle sections just like in org mode
#+BEGIN_SRC emacs-lisp
(sup 'outline-magic)
(add-hook 'tex-mode #'outline-minor-mode)
(define-key outline-minor-mode-map (kbd "<tab>") 'outline-cycle)
#+END_SRC

*** Python
**** IPython
Make ipython the default shell
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --simple-prompt --InteractiveShell.display_page=True")
#+END_SRC

*** Sage
#+BEGIN_SRC emacs-lisp
(sup 'sage-shell-mode)
(setq sage-shell:sage-executable "/usr/bin/sage")
#+END_SRC

*** Clojure
Cider is really good
#+BEGIN_SRC emacs-lisp
(sup 'clojure-mode)
(sup 'cider)
(sp-disable 'clojure-mode "'")
#+END_SRC

*** ASM
The default asm indentation style is completely deranged.
#+BEGIN_SRC emacs-lisp
(defun my-asm-mode-hook ()
  (setq tab-always-indent (default-value 'tab-always-indent)))

(add-fs-to-hook 'asm-mode-hook
                (local-unset-key (vector asm-comment-char))
                (setq tab-always-indent (default-value 'tab-always-indent)))
#+END_SRC

*** Other
Kmonad config lang. Only load when the file exists.
#+BEGIN_SRC emacs-lisp
(when (file-exists-p (concat user-emacs-directory "kbd-mode.el"))
  (load-file "~/.emacs.d/kbd-mode.el")
  (add-hook 'kbd-mode-hook (fn (aggressive-indent-mode -1))))
#+END_SRC

* Other config and elisp
** User information
Add some variables that various programs, especially mail programs
use.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Eshan Ramesh"
      user-mail-address "esrh@gatech.edu")
#+END_SRC

** Yes or no to y/n
Turn the yes or no prompts into y or n prompts. This makes it easier
and faster to type since emacs will insist you type out y e s.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Don't ask about vc links
Don't ask for confirmation when i visit a git-controlled source file.
This is especially helpful when you want to get to a build file from a
help page from some package installed by straight.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks nil)
#+END_SRC

** Don't confirm on buffer kill
Living dangerously! Don't confirm when killing a buffer.
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
      (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

** Temporary files in /tmp
Taken from emacswiki. Makes emacs stop littering your working
directories with autosave information. Instead, leave them all in
~/tmp/emacsXXXX~  where ~XXXX~ is a user unique id (which prevents
multiple users (who don't exist on my computers) from having
conflicting auto save files).

#+BEGIN_SRC emacs-lisp
(defconst emacs-tmp-dir
  (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
(setq backup-directory-alist
      `((".*" . ,emacs-tmp-dir)))
(setq auto-save-file-name-transforms
      `((".*" ,emacs-tmp-dir t)))
(setq auto-save-list-file-prefix
      emacs-tmp-dir)
#+END_SRC

** Make directories in find-file
#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir t)))))
#+END_SRC

** Split and follow
Does what it says on the tin. I feel like everyone has some version of
these functions copied from somewhere or another on the internet.
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
#+END_SRC

Bind these new functions to override the old ones
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Delete frame and buffer
Taken from [[https://emacs.stackexchange.com/questions/2888/kill-buffer-when-frame-is-deleted][here]]
#+BEGIN_SRC emacs-lisp
(defun maybe-delete-frame-buffer (frame)
  "When a dedicated FRAME is deleted, also kill its buffer.
  A dedicated frame contains a single window whose buffer is not
  displayed anywhere else."
  (let ((windows (window-list frame)))
    (when (eq 1 (length windows))
      (let ((buffer (window-buffer (car windows))))
        (when (eq 1 (length (get-buffer-window-list buffer nil t)))
          (kill-buffer buffer))))))
(add-hook 'delete-frame-functions #'maybe-delete-frame-buffer)
#+END_SRC

** Custom keybinds
*** Kill both buffer and window keybinding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-buffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer-and-window)
#+END_SRC

** Spellcheck locale
Taken from here: http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs/
#+BEGIN_SRC emacs-lisp
(cond
 ;; try hunspell at first
  ;; if hunspell does NOT exist, use aspell
 ((executable-find "hunspell")
  (setq ispell-program-name "hunspell")
  (setq ispell-local-dictionary "en_US")
  (setq ispell-local-dictionary-alist
        ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell
        ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

  ;; new variable `ispell-hunspell-dictionary-alist' is defined in Emacs
  ;; If it's nil, Emacs tries to automatically set up the dictionaries.
  (when (boundp 'ispell-hunspell-dictionary-alist)
    (setq ispell-hunspell-dictionary-alist ispell-local-dictionary-alist)))

 ((executable-find "aspell")
  (setq ispell-program-name "aspell")
  ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
  (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
#+END_SRC

** Switch two buffers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x w") 'ace-swap-window)
#+END_SRC

** Function to reload init
I make too many changes to type this out every time.
#+BEGIN_SRC emacs-lisp
(defun load-init ()
  (interactive)
  (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC

** Load current file
#+BEGIN_SRC emacs-lisp
(defun load-this-file ()
  (interactive)
  (load-file (buffer-file-name)))

(define-key emacs-lisp-mode-map (kbd "C-c C-b") 'load-this-file)
#+END_SRC

** Kill other buffers
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

** Spaces over tabs
I don’t like tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Final newline
#+BEGIN_SRC emacs-lisp
(setq mode-require-final-newline nil)
#+END_SRC

** Aggressive indenting
#+BEGIN_SRC emacs-lisp
(sup 'aggressive-indent-mode)
(add-hook 'lisp-data-mode-hook #'aggressive-indent-mode)
#+END_SRC

** Scratch config
Set the initial mode to be lisp interaction. No default text.
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'lisp-interaction-mode)
(setq initial-scratch-message "")
#+END_SRC

** Disable dialog boxes
#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)
#+END_SRC

** C-x remap
Important code that switches ~C-x~ and ~C-u~. This is helpful for me
because I use dvorak, and ~C-x~ is far more common and useful compared
te ~C-u~. This must be at the end of the file because it basically
redefines every other command that I bound to the ~C-x~ prefix anywhere
above.
#+BEGIN_SRC emacs-lisp
(define-key key-translation-map [?\C-x] [?\C-u])
(define-key key-translation-map [?\C-u] [?\C-x])
#+END_SRC

** Use ripgrep when available
grep-find is a cool feature, but grep is sometimes slow. Use ripgrep
if available. I'm aware that separate packages exist for ripgrep, but
this works completely fine for me.
#+BEGIN_SRC emacs-lisp
(when (executable-find "rg")
  (grep-apply-setting
   'grep-find-command
   '("rg -n -H --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 27)))
#+END_SRC
