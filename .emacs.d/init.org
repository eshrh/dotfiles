---
title: Emacs Configuration
---
#+PROPERTY: header-args :tangle "init.el"
#+TITLE: My Emacs configuration
#+TOC: headlines 2

This is my literate init.el file. There are a lot of highly opinionated choices
here! My config is in a constant state of disrepair. If you’re reading this on
my website, then this is probably quite close to my current config since this
file is updated by the website’s build script.

* Internals
** Performance
Increase gc threshold. This is at the top of the file to ensure that
it benfits startup time.
#+BEGIN_SRC emacs-lisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
(setq gc-cons-threshold 100000000)
#+END_SRC

** Packages & Straight bootstrapping
I use [[https://github.com/raxod502/straight.el][straight.el]] for my package management. I find it to be much more flexible than
plain use-package or package.el. Also, it has much better portability and
version stability. Finally, I find its recipe-writing features very nice.
#+BEGIN_SRC emacs-lisp
(setq straight-check-for-modifications '(find-when-checking))
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
    (url-retrieve-synchronously
     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
     'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

straight-use-package is a bit of a keyful to type.
#+BEGIN_SRC emacs-lisp
(defalias 'sup 'straight-use-package)
#+END_SRC

** User information
Some user information that various programs use
#+begin_src emacs-lisp
(setq user-full-name "Eshan Ramesh"
      user-mail-address "esrh@gatech.edu")
#+end_src

** Yes-or-no

Turn the yes-or-no prompt into a y/n prompt to make it faster to type.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Don't ask about vc links
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks nil)
#+END_SRC

** Don’t confirm on buffer kill
living dangerously!
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
	  (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

** Temporary files
Don’t clutter directories
#+BEGIN_SRC emacs-lisp
(defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
(setq backup-directory-alist
      `((".*" . ,emacs-tmp-dir)))
(setq auto-save-file-name-transforms
      `((".*" ,emacs-tmp-dir t)))
(setq auto-save-list-file-prefix
      emacs-tmp-dir)
#+END_SRC

** Make directories in find-file
Don’t make me think ahead
#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir t)))))
#+END_SRC

** JIT

I use a self-compiled version of emacs with native compilation enabled. The
first line enabled deferred comp so that elisp is compiled async when its first
called. The second line is so that I don’t see annoying popups every time.
#+BEGIN_SRC emacs-lisp
(setq comp-deferred-compilation t)
(setq warning-suppress-log-types '((comp)))
#+END_SRC

** make C-h backspace
#+BEGIN_SRC emacs-lisp
(global-set-key [?\C-h] 'delete-backward-char)
(global-set-key [?\C-x ?h] 'help-command)
#+END_SRC

* Visual configuration
** Disable bell
I don’t know who thought it was a good idea to include this.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Disable UI bloat
Turn off the menu-bar, tool-bar, an scroll-bar. I hate bars!
#+BEGIN_SRC emacs-lisp
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)

(scroll-bar-mode -1)
#+END_SRC

** Extra information
I can’t count parentheses. I use an advice override to change how th paren
locating functionality works. This is because I use a block cursor with meow,
which makes cursor position slightly deceptive.
#+BEGIN_SRC emacs-lisp
(column-number-mode)
(show-paren-mode)
(defun show-paren--locate-near-paren-ad ()
  "Locate an unescaped paren \"near\" point to show.
If one is found, return the cons (DIR . OUTSIDE), where DIR is 1
for an open paren, -1 for a close paren, and OUTSIDE is the buffer
position of the outside of the paren.  Otherwise return nil."
  (let* ((before (show-paren--categorize-paren (point))))
    (when (or
       (eq (car before) 1)
       (eq (car before) -1))
      before)))

(advice-add 'show-paren--locate-near-paren
            :override #'show-paren--locate-near-paren-ad)
#+END_SRC
Colorize color strings.
#+BEGIN_SRC emacs-lisp
(sup 'rainbow-mode)
(rainbow-mode)
#+END_SRC
highlight the line the point is on.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda () (setq show-trailing-whitespace nil)))
#+END_SRC

** Font config
Emacs sometimes doesn’t play well with fullwidth CJK alongside normal english
characters. I look at a fair bit of Japanese in
emacs, so I use a workaround to make this work.
*** Variable declarations
My default fonts. Hack is a very nice font that I use for everything I can, and
I use IPAGothic because I don’t know anything better.
#+BEGIN_SRC emacs-lisp
(defvar emacs-english-font "Iosevka Hane Sans")
(defvar emacs-cjk-font "IPAGothic")

(setq my-font (concat emacs-english-font "-12"))

(add-to-list 'default-frame-alist `(font . ,my-font))
(set-face-attribute 'default t :font my-font)
;; (set-face-attribute 'default t :font my-font)
;; (set-frame-font my-font nil t)
#+END_SRC

*** CJK hacks
The general idea is to always have the english and CJK font sizes match each other.
This workaround is from [[https://gist.github.com/coldnew/7398845][here]] with my additions. I don’t actually use this hack
at the moment because it’s only useful in a very specific situation (when
english and cjk are combined inline and string-width is very important), but it
exposes (configure-fonts) which solves it.

**** Font size pairs
First, we set initial fonts and keep an alist of correct font sizes. I’m not
entirely sure where these numbers come from, but they seem to work. 
#+BEGIN_SRC emacs-lisp
(defvar emacs-font-size-pair '(17 . 20))
(defvar emacs-font-size-pair-list
  '(( 5 .  6) (10 . 12)
    (13 . 16) (15 . 18) (17 . 20)
    (19 . 22) (20 . 24) (21 . 26)
    (24 . 28) (26 . 32) (28 . 34)
    (30 . 36) (34 . 40) (36 . 44))
  "This list is used to store matching (english . japanese) font-size.")
#+END_SRC
**** Set the size of english and CJK fonts together
We first set the english font size in the standard way, and then set the
cjk font for all the correct charsets using the appropriate size.
#+BEGIN_SRC emacs-lisp
(defun set-font-frame (english japanese size-pair frame)
  "Setup emacs English and Japanese font on x window-system."
  (set-frame-font (format "%s:pixelsize=%d" english (car size-pair)) t (list frame))
  ;;(set-face-attribute 'default nil :font english)
  (dolist (charset '(kana han symbol cjk-misc bopomofo))
	(set-fontset-font (frame-parameter frame 'font) charset
					  (font-spec :family japanese :size (cdr size-pair)))))
#+END_SRC
**** Step font sizes together
Step the font size of both english and CJK fonts together.
#+BEGIN_SRC emacs-lisp
(defun emacs-step-font-size (step)
  "Increase/Decrease emacs's font size."
  (let ((scale-steps emacs-font-size-pair-list))
    (if (< step 0) (setq scale-steps (reverse scale-steps)))
    (setq emacs-font-size-pair
          (or (cadr (member emacs-font-size-pair scale-steps))
              emacs-font-size-pair))
    (when emacs-font-size-pair
      (message "emacs font size set to %.1f" (car emacs-font-size-pair))
      (set-font-frame emacs-english-font emacs-cjk-font emacs-font-size-pair (selected-frame)))))
#+END_SRC

**** Auto-configure fonts
This is a really nasty hack to make the fonts get set to the correct size on
startup, using the fact that my first window when starting emacs is dashboard.
#+BEGIN_SRC emacs-lisp
(defun configure-fonts (frame)
  (when (display-graphic-p frame)
	(progn 
	  (set-font-frame emacs-english-font emacs-cjk-font emacs-font-size-pair frame))))

;;(add-hook 'after-make-frame-functions #'configure-fonts)
;;(add-hook 'dashboard-mode-hook (lambda ()
;;                                 (configure-fonts (selected-frame))))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp
(sup 'gruvbox-theme)
(load-theme 'gruvbox-dark-hard t nil)
(setq solarized-high-contrast-mode-line t)
(setq solarized-use-less-bold t)
(setq solarized-use-more-italic t)
(setq solarized-height-minus-1 1.0)
(setq solarized-height-plus-1 1.0)
(setq solarized-height-plus-2 1.0)
(setq solarized-height-plus-3 1.0)
(setq solarized-height-plus-4 1.0)
(setq x-underline-at-descent-line t)
#+END_SRC

** Frame
Make the title look better so that my status bar(xmobar) can print it nicely
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("emacs: %b"))
#+END_SRC

** Extra highlighting
Install a bunch of Fanael’s visual packages to make lisp source editing much
nicer.
+ highlight-defined: highlight known symbols instead of just the built in ones
+ highlight-numbers: numbers
+ highlight-delimiters: highlight brackets and parens nicely
+ highlight-quoted: highlight quoted symbols in a different color
#+BEGIN_SRC emacs-lisp
(sup 'highlight-defined)
(sup 'highlight-numbers)
(sup 'rainbow-delimiters)
(sup 'highlight-quoted)
(defun highlight-lisp-things-generic ()
  (highlight-numbers-mode)
  (highlight-defined-mode)
  (rainbow-delimiters-mode))

(defun highlight-lisp-things ()
  (highlight-lisp-things-generic)
  (highlight-quoted-mode))

(add-hook 'emacs-lisp-mode-hook #'highlight-lisp-things)
(add-hook 'lisp-data-mode-hook #'highlight-lisp-things-generic)
(add-hook 'clojure-mode-hook #'highlight-lisp-things-generic)
#+END_SRC

** Modeline
I've liked smart-mode-line in the past, but I prefer telephone line's
modularity, design, and visual appeal right now.

#+BEGIN_SRC emacs-lisp
(sup 'telephone-line)
#+END_SRC


Use a neat cubic curved shape to separate segments.
#+BEGIN_SRC emacs-lisp
(require 'telephone-line)
(setq telephone-line-primary-left-separator 'telephone-line-cubed-left
      telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
      telephone-line-primary-right-separator 'telephone-line-cubed-right
      telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
(setq telephone-line-height 24
      telephone-line-evil-use-short-tag t)
#+END_SRC


Segment setup:
#+BEGIN_SRC emacs-lisp
;; patch submitted, waiting on upstream
(telephone-line-defsegment* telephone-line-simpler-major-mode-segment ()
  (concat "["
          (if (listp mode-name)
              (car mode-name)
            mode-name) "]"))

(telephone-line-defsegment* telephone-line-simple-pos-segment ()
  (concat "%c : " "%l/" (number-to-string (count-lines (point-min) (point-max))) ))
(setq telephone-line-evil-use-short-tag nil)
(setq telephone-line-lhs
      '((nil . (telephone-line-projectile-buffer-segment))
        (accent . (telephone-line-simpler-major-mode-segment))
        (nil . (telephone-line-meow-tag-segment
                telephone-line-misc-info-segment)))
      telephone-line-rhs
      '((nil . (telephone-line-simple-pos-segment))
        (accent . (telephone-line-buffer-modified-segment))))
(telephone-line-mode 1)
#+END_SRC
I wrote the meow segment for telephone line, but it has been
upstreamed now.

** Indent guides
#+BEGIN_SRC emacs-lisp
(sup 'highlight-indent-guides)
(setq highlight-indent-guides-method 'character)
; (add-hook 'prog-mode-hook #'highlight-indent-guides-mode)
#+END_SRC

** Pixel scrolling
#+BEGIN_SRC emacs-lisp
(defun pixel-scroll-setup ()
  (interactive)
  (setq pixel-scroll-precision-large-scroll-height 30.0)
  (setq pixel-scroll-precision-interpolation-factor 20))

(when (boundp 'pixel-scroll-precision-mode)
  (pixel-scroll-setup)
  (add-hook 'prog-mode-hook #'pixel-scroll-precision-mode)
  (add-hook 'org-mode-hook #'pixel-scroll-precision-mode))
#+END_SRC

* Packages
** Libraries
#+BEGIN_SRC emacs-lisp
  (sup 's)
  (sup 'dash)
#+END_SRC

** Neotree
#+BEGIN_SRC emacs-lisp
(sup 'neotree)
(setq neo-theme (if (display-graphic-p) 'ascii))
#+END_SRC

** Nyaatouch
Nyaatouch is my personal modal editing system. It is highly optimized for the
dvorak keyboard and is built on meow (hence the name).

#+BEGIN_SRC emacs-lisp
(sup '(nyaatouch
       :repo "https://github.com/eshrh/nyaatouch"
       :fetcher github))
(require 'nyaatouch)
(turn-on-nyaatouch)
(meow-normal-define-key '("r" . meow-delete))
(setq  x-meta-keysym 'super
       x-super-keysym 'meta)

#+END_SRC

Nyaatouch brings in some packages as dependencies: avy, swiper, meow,
smartparens. You can find more information about it at the repo.

#+BEGIN_SRC emacs-lisp
(meow-leader-define-key
 '("d" . vterm-toggle-cd))
#+END_SRC

** Undo-tree
#+BEGIN_SRC emacs-lisp
(sup 'undo-tree)
(global-undo-tree-mode)
(setq undo-tree-auto-save-history nil)
#+END_SRC

** Ace-window
Ace-window is super nice because it lets you quickly switch to a window
when you have >2 open by providing a letter hint.
#+BEGIN_SRC emacs-lisp
(sup 'ace-window)
(global-set-key [remap other-window] 'ace-window)
#+END_SRC

I add some extra config for myself
#+BEGIN_SRC emacs-lisp
(setq aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s))
(setq aw-scope 'frame)
(setq aw-background nil)
(setq aw-ignore-current t)
#+END_SRC

** Dashboard
An essential. 
#+BEGIN_SRC emacs-lisp
(sup 'dashboard)
(dashboard-setup-startup-hook)
#+END_SRC

Some config
#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice (get-buffer "*dashboard*"))
(setq dashboard-center-content t)
(setq dashboard-show-shortcuts nil)
(setq dashboard-set-init-info nil)
(setq dashboard-set-footer nil)

(setq dashboard-items '((recents  . 5)
                        (projects . 5)
                        (agenda . 5)))

(setq dashboard-agenda-sort-strategy '(time-up))

(setq dashboard-item-names '(("Recent Files:" . "recent:")
                             ("Projects:" . "projects:")
                             ("Agenda for the coming week:" . "agenda:")))

(setq dashboard-banner-logo-title "GNU emacsへようこそ。")

(if (or (display-graphic-p) (daemonp))
    (progn (setq dashboard-startup-banner (expand-file-name "hiten_render_rsz.png" user-emacs-directory)))
    (progn (setq dashboard-startup-banner (expand-file-name "gnu.txt" user-emacs-directory))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'recentf-exclude
             (concat (getenv "HOME") "/org"))
#+END_SRC

** Company
The one true autocompleter
#+BEGIN_SRC emacs-lisp
(sup 'company)
(add-hook 'after-init-hook 'global-company-mode)
(sup 'company-ctags)
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(sup 'projectile)
(projectile-mode +1)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun find-file-or-projectile ()
  (interactive)
  (if (projectile-project-p)
      (call-interactively 'projectile-find-file)
    (call-interactively 'find-file)))

(global-set-key (kbd "C-x C-f") 'find-file-or-projectile)
(meow-leader-define-key
 '("U" . find-file))
#+END_SRC

** Searching
*** Ivy
I currently use ivy for completions. I’ve used selectrum in the past,
but ivy is better in my opinion simply because so many packages have
built in integrations with it. I also use swiper extensively, which is
why i find it hard to switch.

#+BEGIN_SRC emacs-lisp
(sup 'ivy)
(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
#+END_SRC
Typing things over and over again is hard. Prescient keeps track of command
history and does some magic to make recent command appear higher up.
#+BEGIN_SRC emacs-lisp
(sup 'prescient)
(sup 'ivy-prescient)
(ivy-prescient-mode)
#+END_SRC

*** Marginalia
An essential addition to the search minibuffer that offers a bit of documentation.
#+BEGIN_SRC emacs-lisp
(sup 'marginalia)
(marginalia-mode)
#+END_SRC

*** Posframe
#+BEGIN_SRC emacs-lisp
(sup 'posframe)
(sup 'ivy-posframe)
(setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
(setq ivy-posframe-display-functions-alist
      '((swiper          . ivy-display-function-fallback)
        (org-ref-insert-link . ivy-display-function-fallback)
        (t               . ivy-posframe-display)))

(ivy-posframe-mode 1)
#+END_SRC

** Helpful
Better describe* functions that have more information and look neater.

#+BEGIN_SRC emacs-lisp
(sup 'helpful)
#+END_SRC

Override keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x h C-f") #'helpful-callable)
(global-set-key (kbd "C-x h C-v") #'helpful-variable)
(global-set-key (kbd "C-x h C-k") #'helpful-key)
(global-set-key (kbd "C-x h f") #'helpful-callable)
(global-set-key (kbd "C-x h v") #'helpful-variable)
(global-set-key (kbd "C-x h k") #'helpful-key)
#+END_SRC

** Japanese-related

#+BEGIN_SRC emacs-lisp
(sup 'anki-editor)
(sup '(sdcv2 :type git
             :repo "https://github.com/manateelazycat/sdcv"
             :files ("sdcv.el")))

(cond ((string= (system-name) "himawari")
       (progn
         (setq sdcv-dictionary-simple-list '("jmdict-ja-en"))
         (setq sdcv-dictionary-complete-list '("jmdict-ja-en"
                                               "J_PLACES"))))
      ((string= (system-name) "shiragiku")
       (progn
         (setq sdcv-dictionary-simple-list '("JMdict_e"))
         (setq sdcv-dictionary-complete-list '("daijisen.tab" "JMdict_e")))))

(setq sdcv-dictionary-data-dir "/usr/share/stardict/dic/")
(setq sdcv-env-lang "ja_JP.UTF-8")
(sup 'clipmon)


#+END_SRC

*** Mecab
This requires mecab to be installed on your system, as well as a dictionary for it.
#+BEGIN_SRC emacs-lisp
(if (executable-find "mecab")
    (sup '(mecab :type git
                 :repo "https://github.com/syohex/emacs-mecab"
                 :pre-build ("make")
                 :files ("mecab-core.so"
                         "mecab-core.o"
                         "mecab-core.c"
                         "mecab.el"))))

#+END_SRC

*** Reading books
Nov-mode is an excellent epub reader.
#+BEGIN_SRC emacs-lisp
(sup 'nov)
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
(setq nov-text-width 100)
#+END_SRC

** Music
#+BEGIN_SRC emacs-lisp
(sup 'emms)
(require 'emms-setup)
(require 'emms-source-file)
(require 'emms-source-playlist)
(require 'emms-playlist-mode)
(require 'emms-browser)
(require 'emms-info)
(require 'emms-info-native)
(setq emms-playlist-default-major-mode #'emms-playlist-mode)
(add-to-list 'emms-track-initialize-functions #'emms-info-initialize-track)
(setq emms-info-functions '(emms-info-native))
(setq emms-track-description-function #'emms-info-track-description)
(add-hook 'emms-browser-mode-hook (lambda () (when (fboundp 'emms-cache)
                                               (emms-cache 1))))
#+END_SRC

browser keybinds
#+BEGIN_SRC emacs-lisp
(define-key emms-browser-mode-map (kbd "<tab>") 'emms-browser-toggle-subitems)
#+END_SRC

*** EMMS browser tree structure
There is currently a bug in emms that makes it unable to parse mpd
albumartist tags. A patch by Pavel Korytov has been accepted upstream,
but it hasn’t made it to me yet.
#+BEGIN_SRC emacs-lisp
(defun emms-info-mpd-process-with-aa (track info)
  (dolist (data info)
    (let ((name (car data))
	      (value (cdr data)))
      (setq name (cond ((string= name "artist") 'info-artist)
		               ((string= name "albumartist") 'info-albumartist)
		               ((string= name "composer") 'info-composer)
		               ((string= name "performer") 'info-performer)
		               ((string= name "title") 'info-title)
		               ((string= name "album") 'info-album)
		               ((string= name "track") 'info-tracknumber)
		               ((string= name "disc") 'info-discnumber)
		               ((string= name "date") 'info-year)
		               ((string= name "genre") 'info-genre)
		               ((string= name "time")
			            (setq value (string-to-number value))
			            'info-playing-time)
		               (t nil)))
      (when name
	    (emms-track-set track name value)))))
#+END_SRC

*** MPD integration setup
#+BEGIN_SRC emacs-lisp
(defun emms-mpd-setup ()
  (require 'emms-player-mpd)
  (setq emms-player-list '(emms-player-mpd))
  (add-to-list 'emms-info-functions 'emms-info-mpd)
  (add-to-list 'emms-player-list 'emms-player-mpd)
  (setq emms-player-mpd-server-name "localhost")
  (setq emms-player-mpd-server-port "6600")
  (setq emms-player-mpd-music-directory "~/mus")
  (advice-add 'emms-info-mpd-process :override 'emms-info-mpd-process-with-aa)
  (emms-player-mpd-connect))

(add-hook 'emms-browser-mode-hook 'emms-mpd-setup)
(add-hook 'emms-playlist-cleared-hook 'emms-player-mpd-clear)
#+END_SRC

** Highlights
*** Highlight todos
#+BEGIN_SRC emacs-lisp
(sup 'hl-todo)
(global-hl-todo-mode)
#+END_SRC

** Which-key
There are too many emacs keybindings and life is too short
#+BEGIN_SRC emacs-lisp
(sup 'which-key)
(which-key-mode)
#+END_SRC

** Format-all
All-purpose code formatter for when things break
#+BEGIN_SRC emacs-lisp
(sup 'format-all)
#+END_SRC

** VTerm
Undoubtedly the best terminal in emacs.
#+BEGIN_SRC emacs-lisp
(sup 'vterm)
(sup 'fish-mode)
#+END_SRC
*** Config
Make hl-line-mode turn off in vterm-mode.
#+BEGIN_SRC emacs-lisp
(setq vterm-kill-buffer-on-exit t)
(setq vterm-buffer-name-string "vt//%s")

(add-hook 'vterm-mode-hook (lambda ()
                             (setq-local global-hl-line-mode
                                         (null global-hl-line-mode))))
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<C-return>") 'vterm-toggle-cd)
    (global-set-key (kbd "<C-S-return>") 'vterm-toggle)
  (when (featurep 'vterm)
    (define-key vterm-mode-map (kbd "C-h") #'vterm-send-backspace))

#+END_SRC

*** Vterm-toggle
toggle a window with a re-usable vterm
#+BEGIN_SRC emacs-lisp
(sup 'vterm-toggle)
(setq vterm-toggle-hide-method 'delete-window)
(setq vterm-toggle-fullscreen-p nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq vterm-toggle-fullscreen-p nil)
(add-to-list 'display-buffer-alist
             '((lambda(bufname _) (with-current-buffer bufname (equal major-mode 'vterm-mode)))
                (display-buffer-reuse-window display-buffer-at-bottom)
                (dedicated . t)
                (reusable-frames . visible)
                (window-height . 0.4)))
#+END_SRC

*** Kill vterm buffer and window
#+BEGIN_SRC emacs-lisp
(defun vterm--kill-vterm-buffer-and-window (process event)
  "Kill buffer and window on vterm process termination."
  (when (not (process-live-p process))
    (let ((buf (process-buffer process)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (kill-buffer)
          (ignore-errors (delete-window))
          (message "VTerm closed."))))))
(add-hook 'vterm-mode-hook
          (lambda ()
            (set-process-sentinel (get-buffer-process (buffer-name))
                                  #'vterm--kill-vterm-buffer-and-window)))
#+END_SRC

** Org-mode
Path configuration. I use a directory called org in my home directory to store
my org files.
#+BEGIN_SRC emacs-lisp
(sup 'org)
(sup 'ox-pandoc)
(when (file-exists-p "~/org/")
  (setq org-directory "~/org/")
  (setq org-agenda-files '("~/org/")))
(setq org-hide-emphasis-markers t)
(setq org-list-allow-alphabetical t)
(add-hook 'org-mode-hook (lambda ()
                           (org-indent-mode 1)
                           (electric-quote-mode -1)
                           (auto-fill-mode 1)))
#+END_SRC

Don't insert lines in between headers and list items.
#+BEGIN_SRC emacs-lisp
(setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
#+END_SRC


Change the backends
#+BEGIN_SRC emacs-lisp
(setq org-export-backends '(latex beamer md html odt ascii org-ref pandoc))
#+END_SRC

Don't indent code in org-babel
#+BEGIN_SRC emacs-lisp
(setq org-edit-src-content-indentation 0)
#+END_SRC

Even emacs can’t make me not procrastinate!
#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 2)
#+END_SRC

*** Org-fragtog
A neat little package to render latex fragments as you write them.
#+BEGIN_SRC emacs-lisp
(sup 'org-fragtog)

(defun org-inside-latex-block ()
  (eq (nth 0 (org-element-at-point)) 'latex-environment))


(setq org-fragtog-ignore-predicates '(org-at-table-p org-inside-latex-block))

#+END_SRC
*** Org-ref
#+BEGIN_SRC emacs-lisp
  (sup 'org-ref)
  (sup 'ivy-bibtex)
  (require 'org-ref-ivy)

  (setq org-src-fontify-natively t
        org-confirm-babel-evaluate nil
        org-src-preserve-indentation t)

  (setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body
        org-ref-insert-cite-function 'org-ref-cite-insert-ivy
        org-ref-insert-label-function 'org-ref-insert-label-link
        org-ref-insert-ref-function 'org-ref-insert-ref-link
        org-ref-cite-onclick-function (lambda (_) (org-ref-citation-hydra/body)))
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)
    (define-key org-mode-map (kbd "S-]") 'org-ref-insert-link-hydra/body))
    ; (define-key org-mode-map (kbd "C-c C-e") 'org-ref-export-from-hydra))

  (setq bibtex-completion-bibliography '("~/docs/library.bib"))

  (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
  (add-hook 'doc-view-mode-hook 'auto-revert-mode)

  (define-key org-mode-map (kbd "C-c r") 'org-ref-citation-hydra/body)
#+END_SRC
*** Org-roam
#+BEGIN_SRC emacs-lisp
(sup 'org-roam)
(setq org-roam-v2-ack t)
#+END_SRC

basic setup
org-roam-db-autosync-mode is nice,
but adds about 1.5s to my startup time. Not good!
#+BEGIN_SRC emacs-lisp
(unless (file-directory-p "~/roam")
  (make-directory "~/roam"))

(setq org-roam-directory (file-truename "~/roam"))
(global-set-key (kbd "C-c c i") #'org-roam-node-insert)
(global-set-key (kbd "C-c c f") #'org-roam-node-find)
(global-set-key (kbd "C-c c s") #'org-roam-db-sync)
(global-set-key (kbd "C-c c p") (lambda () (interactive)
                                  (load-file "~/roam/publish.el")))
(setq org-return-follows-link t)

(setq org-roam-capture-templates
      '(("d" "default" plain "%?" :target
         (file+head "${slug}.org" "#+title: ${title}\n")
         :unnarrowed t)))
#+END_SRC

*** Anki integration
#+BEGIN_SRC emacs-lisp
(defun anki-description-transform ()
  (interactive)
  (let* ((begin (re-search-backward "^-"))
         (end (forward-sentence))
         (raw (buffer-substring-no-properties
               begin
               end))
         (split (s-split "::" raw))
         (q (substring (s-trim (car split)) 2))
         (a (s-trim (cadr split)))
         (depth (org-current-level)))
    (yas-expand-snippet
     (yas-lookup-snippet "anki-editor card")
     begin end)
    (insert q)
    (yas-next-field-or-maybe-expand)
    (insert a)
    (yas-end)
    (org-backward-element)))
#+END_SRC

*** Latex
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("IEEEtran"
                 "\\documentclass{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))

#+END_SRC

** IRC
I store this outside of vc because it has some secrets.
#+BEGIN_SRC emacs-lisp
(setq erc-default-server "irc.libera.chat")
(add-hook 'erc-before-connect (lambda ()
                                (when (file-exists-p "ircconfig.elc")
                                  (load
                                   (expand-file-name
                                    "ircconfig"
                                    user-emacs-directory)))))
#+END_SRC

** YASnippet
#+BEGIN_SRC emacs-lisp
(sup 'yasnippet)
(yas-global-mode)
(setq yas-indent-line 'fixed)
#+END_SRC

** Dired+
#+BEGIN_SRC emacs-lisp
(sup 'dired+)
#+END_SRC

** Elfeed
#+BEGIN_SRC emacs-lisp
(sup 'elfeed)
(setq elfeed-feeds
      '("https://sachachua.com/blog/feed/"
        "https://hnrss.org/frontpage"))
#+END_SRC

Make links open in eww.
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
#+END_SRC

** Flycheck
Classic linter framework
#+BEGIN_SRC emacs-lisp
(sup 'flycheck)
#+END_SRC

** Magit
Nothing to be said here
#+BEGIN_SRC emacs-lisp
(sup 'magit)

(setq ediff-diff-options "")
(setq ediff-custom-diff-options "-u")
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq ediff-split-window-function 'split-window-vertically)

#+END_SRC

** EAF
#+BEGIN_SRC emacs-lisp
(when (file-directory-p (concat
                         user-emacs-directory
                         "site-lisp/emacs-application-framework/"))
  (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
  (require 'eaf)
  (require 'eaf-pdf-viewer)
  (require 'eaf-org-previewer)
  (require 'eaf-browser)
  (require 'eaf-image-viewer)
  (require 'eaf-terminal))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'eaf-mode-hook (lambda () (interactive)
			   (define-key eaf-mode-map (kbd "SPC") 'meow-keypad)))
#+END_SRC

** Ligatures and symbols
#+BEGIN_SRC emacs-lisp
;; custom entry in tex--prettify-symbols-alist. FIXME.
;; (global-prettify-symbols-mode)
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
(sup 'lsp-mode)
(sup 'lsp-ui)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(sup 'lsp-haskell)
#+END_SRC

config
#+BEGIN_SRC emacs-lisp
(setq lsp-auto-guess-root t)
(setq lsp-enable-symbol-highlighting nil)
(setq lsp-lens-enable nil)
(setq lsp-headerline-breadcrumb-enable nil)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook #'lsp-deferred)
(add-hook 'haskell-mode-hook #'lsp-deferred)
(add-hook 'c-mode-hook #'lsp-deferred)
#+END_SRC

** Language-specific
*** Java
#+BEGIN_SRC emacs-lisp
(sup 'meghanada)
(add-hook 'java-mode-hook
          (lambda ()
            ;; meghanada-mode on
            (meghanada-mode t)
            (flycheck-mode +1)
            (setq c-basic-offset 4)
			(setq tab-width 4))
          (lambda ()
            (add-hook 'before-save-hook #'delete-trailing-whitespace)))
#+END_SRC

#+BEGIN_SRC emacs-lisp

#+END_SRC

*** Haskell
#+BEGIN_SRC emacs-lisp
(sup 'haskell-mode)
(add-hook 'haskell-mode-hook #'interactive-haskell-mode)
#+END_SRC

Interactive haskell error customization
#+BEGIN_SRC emacs-lisp
(setq haskell-interactive-popup-errors t)
#+END_SRC

*** C++
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              c-basic-offset 4
              kill-whole-line t
              indent-tabs-mode nil)
#+END_SRC

*** Lisp
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook 'flycheck-mode)
(sup 'slime)
(setq inferior-lisp-program "sbcl")

(sup 'slime-company)
(add-hook 'common-lisp-mode-hook (lambda ()
                              (slime-setup '(slime-fancy slime-company))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst lisp--prettify-symbols-alist
  '(("lambda"  . ?λ)))
(add-hook 'elisp-mode-hook 'prettify-symbols-mode)
(add-hook 'lisp-mode-hook 'prettify-symbols-mode)
(add-hook 'clojure-mode-hook 'prettify-symbols-mode)
(add-hook 'python-mode-hook 'prettify-symbols-mode)
#+END_SRC

**** Smartparens
#+BEGIN_SRC emacs-lisp
(smartparens-global-mode)
#+END_SRC

Define a function to disable to auto quote-completion. This is
annoying in lisplike languages.

#+BEGIN_SRC emacs-lisp
(defun sp-disable (mode str)
  (sp-local-pair mode str nil :actions nil))
#+END_SRC

Disable single quote pairing in lisp-data modes
#+BEGIN_SRC emacs-lisp
(sp-disable 'lisp-data-mode "'")
#+END_SRC

**** Elisp
#+BEGIN_SRC emacs-lisp
(sup 'elisp-format)
(setq elisp-format-column 80)
(sp-disable 'emacs-lisp-mode "'")
(sp-disable 'emacs-lisp-mode "`")
(sp-disable 'org-mode "'")
#+END_SRC

*** TeX
AuCTeX offers a lot of sweet features that I’ve come to take for granted
#+BEGIN_SRC emacs-lisp
(sup 'auctex)
#+END_SRC

Use evince to view pdfs
#+BEGIN_SRC emacs-lisp
(add-hook 'tex-mode-hook (lambda () (interactive) 
                           (setq TeX-view-program-selection
                                 '((output-pdf "sioyek")))
                           (prettify-symbols-mode)
                           (auto-fill-mode 1)))
#+END_SRC

reftex integration
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook #'turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)
#+END_SRC

*** Python
**** IPython
Make ipython the default shell
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --simple-prompt --InteractiveShell.display_page=True")
#+END_SRC

*** Sage
#+BEGIN_SRC emacs-lisp
(sup 'sage-shell-mode)
(setq sage-shell:sage-executable "/usr/bin/sage")
#+END_SRC

*** Clojure
#+BEGIN_SRC emacs-lisp
(sup 'clojure-mode)
(sup 'cider)
(sp-disable 'clojure-mode "'")
#+END_SRC

*** ASM
#+BEGIN_SRC emacs-lisp
(defun my-asm-mode-hook ()
  ;; you can use `comment-dwim' (M-;) for this kind of behaviour anyway
  
  ;; asm-mode sets it locally to nil, to "stay closer to the old TAB behaviour".
  (setq tab-always-indent (default-value 'tab-always-indent)))

(add-hook 'asm-mode-hook
          (lambda ()
            (local-unset-key (vector asm-comment-char))
            (setq tab-always-indent (default-value 'tab-always-indent))))



#+END_SRC

*** Other
Kmonad config lang
#+BEGIN_SRC emacs-lisp
(when (file-exists-p (concat user-emacs-directory "kbd-mode.el"))
  (load-file "~/.emacs.d/kbd-mode.el")
  (add-hook 'kbd-mode-hook (lambda () (aggressive-indent-mode -1))))
#+END_SRC

* Other config and elisp
** Split and follow
does what it says on the tin.
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
#+END_SRC
Bind these new functions to override the old ones
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Delete frame and buffer
Taken from [[https://emacs.stackexchange.com/questions/2888/kill-buffer-when-frame-is-deleted][here]]
#+BEGIN_SRC emacs-lisp
(defun maybe-delete-frame-buffer (frame)
  "When a dedicated FRAME is deleted, also kill its buffer.
  A dedicated frame contains a single window whose buffer is not
  displayed anywhere else."
  (let ((windows (window-list frame)))
    (when (eq 1 (length windows))
      (let ((buffer (window-buffer (car windows))))
        (when (eq 1 (length (get-buffer-window-list buffer nil t)))
          (kill-buffer buffer))))))
(add-hook 'delete-frame-functions #'maybe-delete-frame-buffer)
#+END_SRC

** Custom keybinds
*** Kill both buffer and window keybinding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-buffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer-and-window)
#+END_SRC

** Spellcheck locale
Taken from here: http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs/
#+BEGIN_SRC emacs-lisp
(cond
 ;; try hunspell at first
  ;; if hunspell does NOT exist, use aspell
 ((executable-find "hunspell")
  (setq ispell-program-name "hunspell")
  (setq ispell-local-dictionary "en_US")
  (setq ispell-local-dictionary-alist
        ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell
        ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries
        '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

  ;; new variable `ispell-hunspell-dictionary-alist' is defined in Emacs
  ;; If it's nil, Emacs tries to automatically set up the dictionaries.
  (when (boundp 'ispell-hunspell-dictionary-alist)
    (setq ispell-hunspell-dictionary-alist ispell-local-dictionary-alist)))

 ((executable-find "aspell")
  (setq ispell-program-name "aspell")
  ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
  (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
#+END_SRC

** Switch two buffers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x w") 'ace-swap-window)
#+END_SRC

** Function to reload init
I make too many changes to type this out every time.
#+BEGIN_SRC emacs-lisp
(defun load-init ()
  (interactive)
  (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC

** Load current file
#+BEGIN_SRC emacs-lisp
(defun load-this-file ()
  (interactive)
  (load-file (buffer-file-name)))

(define-key emacs-lisp-mode-map (kbd "C-c C-b") 'load-this-file)
#+END_SRC

** Kill other buffers
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

** Spaces over tabs
I don’t like tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Final newline
#+BEGIN_SRC emacs-lisp
(setq mode-require-final-newline nil)
#+END_SRC

** Comment keybinding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c /") 'comment-or-uncomment-region)
#+END_SRC

** Aggressive indenting
#+BEGIN_SRC emacs-lisp
(sup 'aggressive-indent-mode)
(add-hook 'lisp-data-mode-hook (lambda () (interactive) (aggressive-indent-mode 1)))
#+END_SRC

** Scratch config
Set the initial mode to be lisp interaction.
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'lisp-interaction-mode)
(setq initial-scratch-message "スクラッチ")
#+END_SRC

** Extra keys to extended command
Rshift on my computer is bound to F19.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f19>") (lambda () (interactive)
                                (call-interactively 'execute-extended-command)))
#+END_SRC

** Disable dialog boxes
#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil)
#+END_SRC

** C-x remap
#+BEGIN_SRC emacs-lisp
(define-key key-translation-map [?\C-x] [?\C-u])
(define-key key-translation-map [?\C-u] [?\C-x])
#+END_SRC

** Use ripgrep when available
#+BEGIN_SRC emacs-lisp
(when (executable-find "rg")
  (grep-apply-setting
   'grep-find-command
   '("rg -n -H --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 27)))
#+END_SRC
