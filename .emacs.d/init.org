---
title: Emacs Configuration
---
#+PROPERTY: header-args :tangle "init.el"
#+TITLE: My Emacs configuration
#+TOC: headlines 2

This is my literate init.el file. There are a lot of highly opinionated choices
here! My config is in a constant state of disrepair. If you’re reading this on
my website, then this is probably quite close to my current config since this
file is updated by the website’s build script.

* Internals
** Packages & Straight bootstrapping
I use [[https://github.com/raxod502/straight.el][straight.el]] for my package management. I find it to be much more flexible than
plain use-package or package.el. Also, it has much better portability and
version stability. Finally, I find its recipe-writing features very nice.
#+BEGIN_SRC emacs-lisp
(setq straight-check-for-modifications '(find-when-checking))
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
    (url-retrieve-synchronously
     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
     'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src
I still keep use-package around just in case, but make it use straight behind
the scenes. This is mostly for some deeper compatibility problems.
#+begin_src emacs-lisp
(straight-use-package 'use-package)
(use-package straight
         :custom (straight-use-package-by-default t))
#+end_src

** User information
Some user information that various programs use
#+begin_src emacs-lisp
(setq user-full-name "Eshan Ramesh"
      user-mail-address "esrh@gatech.edu")
#+end_src

** Yes-or-no
Turn the yes-or-no prompt into a y/n prompt to make it faster to type.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Don’t confirm on buffer kill
living dangerously!
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
	  (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

** Temporary files
Don’t clutter directories
#+BEGIN_SRC emacs-lisp
(defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
(setq backup-directory-alist
      `((".*" . ,emacs-tmp-dir)))
(setq auto-save-file-name-transforms
      `((".*" ,emacs-tmp-dir t)))
(setq auto-save-list-file-prefix
      emacs-tmp-dir)
#+END_SRC

** Make directories in find-file
Don’t make me think ahead
#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir t)))))
#+END_SRC

** JIT
I use a self-compiled version of emacs with native compilation enabled. The
first line enabled deferred comp so that elisp is compiled async when its first
called. The second line is so that I don’t see annoying popups every time.
#+BEGIN_SRC emacs-lisp
(setq comp-deferred-compilation t)
(setq warning-suppress-log-types '((comp)))
#+END_SRC

* Visual configuration
** Line numbers
Turn on global line numbers, with some exceptions. IIRC this segment is taken
from the emacswiki.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'absolute)
(require 'display-line-numbers)

(defcustom display-line-numbers-exempt-modes
  '(vterm-mode eshell-mode dashboard-mode elfeed-search-mode elfeed-show-mode)
  "Major modes on which to disable line numbers."
  :group 'display-line-numbers
  :type 'list
  :version "green")

(defun display-line-numbers--turn-on ()
  "Turn on line numbers except for certain major modes.
Exempt major modes are defined in `display-line-numbers-exempt-modes'."
  (unless (or (minibufferp)
              (member major-mode display-line-numbers-exempt-modes))
    (display-line-numbers-mode)))

(global-display-line-numbers-mode)
#+END_SRC

** Disable bell
I don’t know who thought it was a good idea to include this.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Disable UI bloat
Turn off the menu-bar, tool-bar, an scroll-bar. I hate bars!
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Extra information
I can’t count parentheses. I use an advice override to change how th paren
locating functionality works. This is because I use a block cursor with meow,
which makes cursor position slightly deceptive.
#+BEGIN_SRC emacs-lisp
(column-number-mode)
(show-paren-mode)
(defun show-paren--locate-near-paren-ad ()
  "Locate an unescaped paren \"near\" point to show.
If one is found, return the cons (DIR . OUTSIDE), where DIR is 1
for an open paren, -1 for a close paren, and OUTSIDE is the buffer
position of the outside of the paren.  Otherwise return nil."
  (let* ((before (show-paren--categorize-paren (point))))
    (when (or
       (eq (car before) 1)
       (eq (car before) -1))
      before)))

(advice-add 'show-paren--locate-near-paren
            :override #'show-paren--locate-near-paren-ad)
#+END_SRC
Colorize color strings.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'rainbow-mode)
(rainbow-mode)
#+END_SRC
highlight the line the point is on.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC

** Font config
Emacs sometimes doesn’t play well with fullwidth CJK alongside normal english
characters. I look at a fair bit of Japanese in
emacs, so I use a workaround to make this work.
*** Variable declarations
My default fonts. Hack is a very nice font that I use for everything I can, and
I use IPAGothic because I don’t know anything better.
#+BEGIN_SRC emacs-lisp
(defvar emacs-english-font "Hack")
(defvar emacs-cjk-font "IPAGothic")

(setq my-font (concat emacs-english-font "-12"))
(set-face-attribute 'default t :font my-font)
(set-frame-font my-font nil t)
#+END_SRC

*** CJK hacks
The general idea is to always have the english and CJK font sizes match each other.
This workaround is from [[https://gist.github.com/coldnew/7398845][here]] with my additions. I don’t actually use this hack
at the moment because it’s only useful in a very specific situation (when
english and cjk are combined inline and string-width is very important), but it
exposes (configure-fonts) which solves it.

**** Font size pairs
First, we set initial fonts and keep an alist of correct font sizes. I’m not
entirely sure where these numbers come from, but they seem to work. 
#+BEGIN_SRC emacs-lisp
(defvar emacs-font-size-pair '(17 . 20))
(defvar emacs-font-size-pair-list
  '(( 5 .  6) (10 . 12)
    (13 . 16) (15 . 18) (17 . 20)
    (19 . 22) (20 . 24) (21 . 26)
    (24 . 28) (26 . 32) (28 . 34)
    (30 . 36) (34 . 40) (36 . 44))
  "This list is used to store matching (english . japanese) font-size.")
#+END_SRC
**** Set the size of english and CJK fonts together
We first set the english font size in the standard way, and then set the
cjk font for all the correct charsets using the appropriate size.
#+BEGIN_SRC emacs-lisp
(defun set-font-frame (english japanese size-pair frame)
  "Setup emacs English and Japanese font on x window-system."
  (set-frame-font (format "%s:pixelsize=%d" english (car size-pair)) t (list frame))
  ;;(set-face-attribute 'default nil :font english)
  (dolist (charset '(kana han symbol cjk-misc bopomofo))
	(set-fontset-font (frame-parameter frame 'font) charset
					  (font-spec :family japanese :size (cdr size-pair)))))
#+END_SRC
**** Step font sizes together
Step the font size of both english and CJK fonts together.
#+BEGIN_SRC emacs-lisp
(defun emacs-step-font-size (step)
  "Increase/Decrease emacs's font size."
  (let ((scale-steps emacs-font-size-pair-list))
    (if (< step 0) (setq scale-steps (reverse scale-steps)))
    (setq emacs-font-size-pair
          (or (cadr (member emacs-font-size-pair scale-steps))
              emacs-font-size-pair))
    (when emacs-font-size-pair
      (message "emacs font size set to %.1f" (car emacs-font-size-pair))
      (set-font-frame emacs-english-font emacs-cjk-font emacs-font-size-pair (selected-frame)))))
#+END_SRC

**** Auto-configure fonts
This is a really nasty hack to make the fonts get set to the correct size on
startup, using the fact that my first window when starting emacs is dashboard.
#+BEGIN_SRC emacs-lisp
(defun configure-fonts (frame)
  (when (display-graphic-p frame)
	(progn 
	  (set-font-frame emacs-english-font emacs-cjk-font emacs-font-size-pair frame))))

;;(add-hook 'after-make-frame-functions #'configure-fonts)
;;(add-hook 'dashboard-mode-hook (lambda ()
;;                                 (configure-fonts (selected-frame))))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp
(straight-use-package 'gruvbox-theme)
(if (or (display-graphic-p) (daemonp))
    (load-theme 'gruvbox-dark-hard t nil)
    (load-theme 'tsdh-dark t nil))
#+END_SRC

** Frame
Make the title look better so that my status bar(xmobar) can print it nicely
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("emacs: %b"))
#+END_SRC

** Extra highlighting
Install a bunch of Fanael’s visual packages to make lisp source editing much
nicer.
+ highlight-defined: highlight known symbols instead of just the built in ones
+ highlight-numbers: numbers
+ highlight-delimiters: highlight brackets and parens nicely
+ highlight-quoted: highlight quoted symbols in a different color
#+BEGIN_SRC emacs-lisp
(straight-use-package 'highlight-defined)
(straight-use-package 'highlight-numbers)
(straight-use-package 'rainbow-delimiters)
(straight-use-package 'highlight-quoted)
(defun highlight-lisp-things ()
  (highlight-numbers-mode)
  (highlight-defined-mode)
  (highlight-quoted-mode)
  (rainbow-delimiters-mode))
(add-hook 'emacs-lisp-mode-hook #'highlight-lisp-things)
#+END_SRC

** Modeline
*** SML
Smart mode line is a pretty simple line that does what I need it to. I used to
use powerline, but I found its visuals a bit bloated.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'smart-mode-line)
(setq sml/theme 'respectful)
(setq sml/no-confirm-load-theme t)
(sml/setup)
#+END_SRC

* Packages
** Meow
Meow modal editing. The best parts of vim, kakoune and god-mode, all in one.
*** Custom functions
The point in emacs is always between characters. However, normal
mode in meow is represented by a block cursor, even though the point is really
to the left. This fundamental difference leads to a problem that vim fails to
deal with as well. For instance, entering and exiting insert mode actually moves
your cursor back a full char. On the other hand, meow’s behavior is much more
consistent. However, I think that the granularity of choosing your insert
position is nice, so I redefine a fully different function to model vim’s "a"
without interfering with before and after commands that act on regions.
#+BEGIN_SRC emacs-lisp
(defun meow-insert-right ()
  (interactive)
  (meow-right)
  (meow-insert))
#+END_SRC

The default way to find backwards is - to add a prefix argument and then f to
find. In meow’s default qwerty keyset, the F key is free, so I just make a
function to bind negative searching. Vim muscle memory dies hard i guess.
#+BEGIN_SRC emacs-lisp
(defun meow-negative-find ()
  (interactive)
  (let ((current-prefix-arg -1))
    (call-interactively 'meow-find)))
#+END_SRC

*** Keymap
#+BEGIN_SRC emacs-lisp
(straight-use-package 'meow)

(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("F" . meow-negative-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("/" . meow-insert-right)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-open-below)
   '("O" . meow-open-above)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . swiper)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("/" . avy-goto-word-1)
   '("<escape>" . ignore)))
#+END_SRC

*** Paren mode
Define a meow state for smartparens commands.

#+BEGIN_SRC emacs-lisp
(require 'meow)

(setq meow-paren-keymap (make-keymap))
(meow-define-state paren
  "paren state"
  :lighter " [P]"
  :keymap meow-paren-keymap)

(meow-normal-define-key
 '("Z" . meow-paren-mode))

(meow-define-keys 'paren
  '("<escape>" . meow-normal-mode)
  '("l" . sp-forward-sexp)
  '("h" . sp-backward-sexp)
  '("j" . sp-down-sexp)
  '("k" . sp-up-sexp)
  '("w s" . sp-wrap-square)
  '("w r" . sp-wrap-round)
  '("w c" . sp-wrap-curly)
  '("W" . sp-unwrap-sexp)
  '("n" . sp-forward-slurp-sexp)
  '("b" . sp-forward-barf-sexp)
  '("v" . sp-backward-barf-sexp)
  '("c" . sp-backward-slurp-sexp)
  '("s" . sp-splice-sexp-killing-forward)
  '("S" . sp-splice-sexp-killing-backward)
  '("e" . sp-end-of-sexp)
  '("a" . sp-beginning-of-sexp)
  '("t" . sp-transpose-hybrid-sexp)
  '("u" . meow-undo))

(setq meow-cursor-type-paren 'hollow)
#+END_SRC

*** Enable
#+BEGIN_SRC emacs-lisp
(require 'meow)
(meow-setup)
(meow-global-mode 1)
#+END_SRC

** Ace-window
Ace-window is super nice because it lets you quickly switch to a window
when you have >2 open by providing a letter hint.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'ace-window)
(global-set-key [remap other-window] 'ace-window)
#+END_SRC

I add some extra config for myself
#+BEGIN_SRC emacs-lisp
(setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
(setq aw-scope 'frame)
(setq aw-background nil)
(setq aw-ignore-current t)
#+END_SRC

** Avy
Keybind is in meow-normal-state-keymap
#+BEGIN_SRC emacs-lisp
(straight-use-package 'avy)
#+END_SRC

** Dashboard
An essential. 
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :config (dashboard-setup-startup-hook))
#+END_SRC
Some config
#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice (get-buffer "*dashboard*"))
;;(setq dashboard-startup-banner 1)
(setq dashboard-center-content t)
(setq dashboard-show-shortcuts nil)
(setq dashboard-set-init-info nil)
(setq dashboard-set-footer nil)

(setq dashboard-items '((recents  . 5)
                        (projects . 5)
                        (agenda . 5)))

(setq dashboard-item-names '(("Recent Files:" . "recent:")
                             ("Projects:" . "projects:")
                             ("Agenda for the coming week:" . "agenda:")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
;; (setq dashboard-banner-logo-title (concat "GNU emacsへようこそ。今日は"
;;                                           (format-time-string "%m")
;;                                           "月"
;;                                           (format-time-string "%e")
;;                                           "日です"))
(setq dashboard-banner-logo-title "GNU emacsへようこそ。")
#+END_SRC
#+BEGIN_SRC emacs-lisp
(if (or (display-graphic-p) (daemonp))
    (progn (setq dashboard-startup-banner (expand-file-name "hiten_render_rsz.png" user-emacs-directory)))
    (progn (setq dashboard-startup-banner (expand-file-name "gnu.txt" user-emacs-directory))))
#+END_SRC
** Company
The one true autocompleter
#+BEGIN_SRC emacs-lisp
(straight-use-package 'company)
(add-hook 'after-init-hook 'global-company-mode)
(straight-use-package 'company-ctags)
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(straight-use-package 'projectile)
(projectile-mode +1)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC

** Searching
*** Ivy
I currently use ivy for completions. I’ve used selectrum in the past, but ivy is
better in my opinion simply because so many packages have built in integrations
with it.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'ivy)
(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(setq ivy-count-format "(%d/%d) ")
#+END_SRC
Typing things over and over again is hard. Prescient keeps track of command
history and does some magic to make recent command appear higher up.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'prescient)
(straight-use-package 'ivy-prescient)
(ivy-prescient-mode)
#+END_SRC
Ivy’s twin package for incremental searching, swiper.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'swiper)
#+END_SRC


*** Marginalia
An essential addition to the search minibuffer that offers a bit of documentation.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'marginalia)
(marginalia-mode)
#+END_SRC

** Japanese-related
#+BEGIN_SRC emacs-lisp
(straight-use-package 'anki-editor)
(straight-use-package 'posframe)
(straight-use-package '(sdcv2 :type git
                              :repo "https://github.com/manateelazycat/sdcv"
                              :files ("sdcv.el")))

(cond ((string= (system-name) "himawari")
       (progn
         (setq sdcv-dictionary-simple-list '("jmdict-ja-en"))
         (setq sdcv-dictionary-complete-list '("jmdict-ja-en"
                                               "J_PLACES"))))
      ((string= (system-name) "shiragiku")
       (progn
         (setq sdcv-dictionary-simple-list '("JMdict_e"))
         (setq sdcv-dictionary-complete-list '("daijisen.tab" "JMdict_e")))))

(setq sdcv-dictionary-data-dir "/usr/share/stardict/dic/")
(setq sdcv-env-lang "ja_JP.UTF-8")
(straight-use-package 'clipmon)


#+END_SRC
I use the migemo program to supplement incremental searching for Japanese. It
lets you search for japanese words by typing in romaji. If the program’s not in
path, it is installed automatically on startup.
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'migemo)
  (straight-use-package 'ivy-migemo)
  (straight-use-package 's)

  (unless (executable-find "cmigemo")
    (if (yes-or-no-p "install")
    (make-directory (concat user-emacs-directory "japanese") t)
    (let ((clonedir (concat user-emacs-directory "japanese" "/cmigemo/")))
      (unless (file-directory-p clonedir)
        (magit-clone-internal "https://github.com/koron/cmigemo"
                              nil)))
    (let ((default-directory
            (concat
             user-emacs-directory "japanese" "/cmigemo/")))
      (shell-command "make gcc")
      (shell-command "make gcc-dict")
      (shell-command "cd dict ; make utf-8")
      (shell-command (concat "echo " (shell-quote-argument (read-passwd "Password? "))
                             " | sudo -S make gcc-install")))))
(if (executable-find "cmigemo")
  (require 'migemo)
  (setq migemo-command "cmigemo")
  (setq migemo-options '("-q" "--emacs"))
  (if (file-directory-p "/usr/share/migemo")
      (setq migemo-dictionary "/usr/share/migemo/utf-8/migemo-dict")
    (setq migemo-dictionary (concat user-emacs-directory
                                 "japanese/cmigemo/dict/utf-8.d/migemo-dict")))
  (setq migemo-user-dictionary nil)
  (setq migemo-regex-dictionary nil)
  (setq migemo-coding-system 'utf-8-unix)
  (migemo-init))
#+END_SRC

*** Mecab
This requires mecab to be installed on your system, as well as a dictionary for it.
#+BEGIN_SRC emacs-lisp
(if (executable-find "mecab")
    (straight-use-package '(mecab :type git
                                  :repo "https://github.com/syohex/emacs-mecab"
                                  :pre-build ("make")
                                  :files ("mecab-core.so"
                                          "mecab-core.o"
                                          "mecab-core.c"
                                          "mecab.el"))))

#+END_SRC

*** Reading books
Nov-mode is an excellent epub reader.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'nov)
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
(setq nov-text-width 100)
#+END_SRC

** Music
#+BEGIN_SRC emacs-lisp
(straight-use-package 'emms)
(require 'emms-setup)
(emms-all)
#+END_SRC

MPD integration setup
#+BEGIN_SRC emacs-lisp
(setq emms-player-list '(emms-player-mpd))
(add-to-list 'emms-info-functions 'emms-info-mpd)
(add-to-list 'emms-player-list 'emms-player-mpd)
(setq emms-player-mpd-server-name "localhost")
(setq emms-player-mpd-server-port "6600")
(setq emms-player-mpd-music-directory "~/mus")
(emms-player-mpd-connect)
#+END_SRC
*** EMMS browser tree structure
There is currently a bug in emms that makes it unable to parse mpd albumartist
tags. A patch by Pavel Korytov has been accepted upstream, but it hasn’t made it to me yet.
#+BEGIN_SRC emacs-lisp
(defun emms-info-mpd-process (track info)
  (dolist (data info)
    (let ((name (car data))
	  (value (cdr data)))
      (setq name (cond ((string= name "artist") 'info-artist)
		       ((string= name "albumartist") 'info-albumartist)
		       ((string= name "composer") 'info-composer)
		       ((string= name "performer") 'info-performer)
		       ((string= name "title") 'info-title)
		       ((string= name "album") 'info-album)
		       ((string= name "track") 'info-tracknumber)
		       ((string= name "disc") 'info-discnumber)
		       ((string= name "date") 'info-year)
		       ((string= name "genre") 'info-genre)
		       ((string= name "time")
			(setq value (string-to-number value))
			'info-playing-time)
		       (t nil)))
      (when name
	(emms-track-set track name value)))))
#+END_SRC
** Highlights
*** Highlight todos
#+BEGIN_SRC emacs-lisp
(straight-use-package 'hl-todo)
(global-hl-todo-mode)
#+END_SRC
*** Highlight indent guides
#+BEGIN_SRC emacs-lisp
(straight-use-package 'highlight-indent-guides)
#+END_SRC

** Which-key
There are too many emacs keybindings and life is too short
#+BEGIN_SRC emacs-lisp
(straight-use-package 'which-key)
(which-key-mode)
#+END_SRC

** Format-all
All-purpose code formatter for when things break
#+BEGIN_SRC emacs-lisp
(straight-use-package 'format-all)
#+END_SRC

** VTerm
Undoubtedly the best terminal in emacs.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'vterm)
(straight-use-package 'fish-mode)
#+END_SRC
*** Config
Make hl-line-mode turn off in vterm-mode.
#+BEGIN_SRC emacs-lisp
(setq vterm-kill-buffer-on-exit t)
(setq vterm-buffer-name-string "vt//%s")

(make-variable-buffer-local 'global-hl-line-mode)
(add-hook 'vterm-mode-hook (lambda ()
                             (global-hl-line-mode -1)))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-return>") 'vterm-toggle-cd)
(global-set-key (kbd "<C-S-return>") 'vterm-toggle)
#+END_SRC
*** Vterm-toggle
toggle a window with a re-usable vterm
#+BEGIN_SRC emacs-lisp
(straight-use-package 'vterm-toggle)
(setq vterm-toggle-hide-method 'delete-window)
(setq vterm-toggle-fullscreen-p nil)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq vterm-toggle-fullscreen-p nil)
(add-to-list 'display-buffer-alist
             '((lambda(bufname _) (with-current-buffer bufname (equal major-mode 'vterm-mode)))
                (display-buffer-reuse-window display-buffer-at-bottom)
                ;;(dedicated . t) ;dedicated is supported in emacs27
                (reusable-frames . visible)
                (window-height . 0.3)))
#+END_SRC

*** Kill vterm buffer and window
#+BEGIN_SRC emacs-lisp
(defun vterm--kill-vterm-buffer-and-window (process event)
  "Kill buffer and window on vterm process termination."
  (when (not (process-live-p process))
    (let ((buf (process-buffer process)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (kill-buffer)
          (ignore-errors (delete-window))
          (message "VTerm closed."))))))
(add-hook 'vterm-mode-hook
          (lambda ()
            (set-process-sentinel (get-buffer-process (buffer-name))
                                  #'vterm--kill-vterm-buffer-and-window)))
#+END_SRC
** Org-mode
Path configuration. I use a directory called org in my home directory to store
my org files.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'org)
(setq org-directory "~/org/")
(setq org-agenda-files '("~/org/"))
(setq org-hide-emphasis-markers t)
(setq org-startup-with-latex-preview t)
(add-hook 'org-mode-hook (lambda ()
                           ;;(org-superstar-mode 1)
                           (org-indent-mode 1)
                           (org-fragtog-mode 1)
                           (electric-quote-mode 'nil)
                           (auto-fill-mode 1)))
#+END_SRC

Change the backends
#+BEGIN_SRC emacs-lisp
(setq org-export-backends '(latex beamer md html odt ascii org-ref))

#+END_SRC

Don't indent code in org-babel
#+BEGIN_SRC emacs-lisp
(setq org-edit-src-content-indentation 0)
#+END_SRC

Even emacs can’t make me not procrastinate!
#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 2)
#+END_SRC
*** Org-fragtog
A neat little package to render latex fragments as you write them.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'org-fragtog)
#+END_SRC
*** Org-ref
#+BEGIN_SRC emacs-lisp
(straight-use-package 'org-ref)
(straight-use-package 'ivy-bibtex)
;;(require 'org-ref-ivy)

(setq org-src-fontify-natively t
      org-confirm-babel-evaluate nil
      org-src-preserve-indentation t)

(setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body
      org-ref-insert-cite-function 'org-ref-cite-insert-ivy
      org-ref-insert-label-function 'org-ref-insert-label-link
      org-ref-insert-ref-function 'org-ref-insert-ref-link
      org-ref-cite-onclick-function (lambda (_) (org-ref-citation-hydra/body)))
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)
  (define-key org-mode-map (kbd "S-]") 'org-ref-insert-link-hydra/body)
  (define-key org-mode-map (kbd "C-c C-e") 'org-ref-export-from-hydra))

(setq bibtex-completion-bibliography '("~/docs/library.bib"))

(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
	    "bibtex %b"
	    "pdflatex -interaction nonstopmode -output-directory %o %f"
	    "pdflatex -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
*** Org-roam
#+BEGIN_SRC emacs-lisp
(straight-use-package 'org-roam)
(setq org-roam-v2-ack t)
#+END_SRC

basic setup
org-roam-db-autosync-mode is nice,
but adds about 1.5s to my startup time. Not good!
#+BEGIN_SRC emacs-lisp
(unless (file-directory-p "~/roam")
  (make-directory "~/roam"))

(setq org-roam-directory (file-truename "~/roam"))
;(org-roam-db-autosync-mode)
#+END_SRC
*** Anki integration
#+BEGIN_SRC emacs-lisp
(defun anki-description-transform ()
  (interactive)
  (let* ((begin (re-search-backward "^-"))
         (end (forward-sentence))
         (raw (buffer-substring-no-properties
               begin
               end))
         (split (s-split "::" raw))
         (q (substring (s-trim (car split)) 2))
         (a (s-trim (cadr split)))
         (depth (org-current-level)))
    (yas-expand-snippet
     (yas-lookup-snippet "anki-editor card")
     begin end)
    (insert q)
    (yas-next-field-or-maybe-expand)
    (insert a)
    (yas-end)
    (org-backward-element)))
#+END_SRC

** IRC
I store this outside of vc because it has some secrets.
#+BEGIN_SRC emacs-lisp
(setq erc-default-server "irc.libera.chat")
(when (file-exists-p "ircconfig.elc")
  (load (expand-file-name "ircconfig" user-emacs-directory)))
#+END_SRC

** YASnippet
#+BEGIN_SRC emacs-lisp
(straight-use-package 'yasnippet)
(yas-global-mode)
(setq yas-indent-line 'fixed)
#+END_SRC

** Dired+
#+BEGIN_SRC emacs-lisp
(straight-use-package 'dired+)
#+END_SRC

** AUR
Aur helper in emacs
#+BEGIN_SRC emacs-lisp
(straight-use-package 'aurel)
(setq aurel-info-download-function 'aurel-download-unpack-pkgbuild)
(setq aurel-list-download-function 'aurel-download-unpack-pkgbuild)
#+END_SRC

** Elfeed
#+BEGIN_SRC emacs-lisp
(straight-use-package 'elfeed)
(setq elfeed-feeds
      '("https://sachachua.com/blog/feed/"
        "https://hnrss.org/frontpage"))
#+END_SRC

Make links open in eww.
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'eww-browse-url)
#+END_SRC

** Flycheck
Classic linter framework
#+BEGIN_SRC emacs-lisp
(straight-use-package 'flycheck)
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
(straight-use-package 'company-lsp)
(straight-use-package 'lsp-mode)
(straight-use-package 'lsp-ui)
#+END_SRC
**** Declutter lsp UI
#+BEGIN_SRC emacs-lisp
(setq lsp-ui-doc-show-with-mouse nil)
(setq lsp-ui-sideline-enable nil)
(setq lsp-modeline-code-actions-enable 1)
#+END_SRC

**** Code action keybinding
#+BEGIN_SRC emacs-lisp
(add-hook 'lsp-mode-hook (lambda ()
			   (local-set-key (kbd "C-c C-j") 'lsp-execute-code-action)))
#+END_SRC

**** Performance
#+BEGIN_SRC emacs-lisp
(setq read-process-output-max (* 1024 1024)) ;; 1mb
(setq gc-cons-threshold 100000000)
#+END_SRC

** Magit
Nothing to be said here
#+BEGIN_SRC emacs-lisp
(straight-use-package 'magit)
#+END_SRC

** Telega
telegram client
#+BEGIN_SRC emacs-lisp
(straight-use-package 'telega)
#+END_SRC

** Language-specific
*** Java
I don’t use lsp-java. It’s pretty finicky and doesn’t work how I like it to.
Meghanada on the other hand works perfectly even if it’s a little less feature-rich.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'meghanada)
(add-hook 'java-mode-hook
          (lambda ()
            ;; meghanada-mode on
            (meghanada-mode t)
            (flycheck-mode +1)
            (setq c-basic-offset 4)
			(setq tab-width 4)))
#+END_SRC

*** Haskell
#+BEGIN_SRC emacs-lisp
(straight-use-package 'haskell-mode)
(straight-use-package 'lsp-haskell)
(add-hook 'haskell-mode-hook #'lsp)
(add-hook 'haskell-literate-mode-hook #'lsp)
#+END_SRC

Interactive haskell error customization
#+BEGIN_SRC emacs-lisp
(setq haskell-interactive-popup-errors t)
#+END_SRC

*** C++
I don’t autostart the LSP because i don’t always need it. I enter the lsp manually
if I need to.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              c-basic-offset 4
              kill-whole-line t
              indent-tabs-mode nil)
#+END_SRC

*** Lisp
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook 'flycheck-mode)
(straight-use-package 'slime)
(setq inferior-lisp-program "sbcl")

(straight-use-package 'slime-company)
(slime-setup '(slime-fancy slime-company))
#+END_SRC

**** Elisp
#+BEGIN_SRC emacs-lisp
(straight-use-package 'elisp-format)
(setq elisp-format-column 80)
#+END_SRC
**** Smartparens
#+BEGIN_SRC emacs-lisp
(straight-use-package 'smartparens)
(smartparens-global-mode)
(sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
(sp-local-pair 'emacs-lisp-mode "`" nil :actions nil)
#+END_SRC

*** TeX
AuCTeX offers a lot of sweet features that I’ve come to take for granted
#+BEGIN_SRC emacs-lisp
(straight-use-package 'auctex)
#+END_SRC

Use zathura to view pdfs
#+BEGIN_SRC emacs-lisp
(setq TeX-view-program-selection '((output-pdf "Zathura")))
#+END_SRC

I use the digestif LSP. I don’t like the lens in this mode, so I turn it off.
#+BEGIN_SRC emacs-lisp
(add-hook 'tex-mode #'lsp)
(add-hook 'tex-mode (lambda ()
					  (setq lsp-lens-enable nil)))
#+END_SRC

*** Python
#+BEGIN_SRC emacs-lisp
(straight-use-package 'lsp-jedi)
(add-hook 'python-mode #'lsp)
#+END_SRC
**** IPython
#+BEGIN_SRC emacs-lisp
(straight-use-package 'polymode)
(straight-use-package 'ein)
(setq ein:polymode t)
#+END_SRC

*** Sage
#+BEGIN_SRC emacs-lisp
(straight-use-package 'sage-shell-mode)
(setq sage-shell:sage-executable "/usr/bin/sage")
#+END_SRC

*** Janet
#+BEGIN_SRC emacs-lisp
(straight-use-package 'janet-mode)
(straight-use-package
 '(ijanet
   :type git
   :host github
   :repo "serialdev/ijanet-mode"
))
(defun janet-key-config ()
    (interactive)
    (define-key janet-mode-map (kbd "C-c C-l") 'ijanet-eval-line)
    (define-key janet-mode-map (kbd "C-c C-p") 'ijanet)
    (define-key janet-mode-map (kbd "C-c C-b") 'ijanet-eval-buffer)
    (define-key janet-mode-map (kbd "C-c C-r") 'ijanet-eval-region))
#+END_SRC

I'd like to develop some janet tooling in the future myself, especially with regards to the repl.
#+BEGIN_SRC emacs-lisp
(straight-use-package
  '(janet-editor-elf :host github
                     :repo "sogaiu/janet-editor-elf"
                     :files ("*.el" "janet-editor-elf")))

(use-package janet-editor-elf
  :straight t
  :config
  (add-hook 'janet-mode-hook
            (lambda ()
              (setq-local indent-line-function
                          #'jee-indent-line))))

#+END_SRC

Sogaiu's other repl package for janet
#+BEGIN_SRC emacs-lisp
(straight-use-package
  '(ajrepl :host github
           :repo "sogaiu/ajrepl"
           :files ("*.el" "ajrepl")))

(use-package ajrepl
  :straight t
  :config
  (add-hook 'janet-mode-hook
            #'ajrepl-interaction-mode))
#+END_SRC

*** Clojure
#+BEGIN_SRC emacs-lisp
(straight-use-package 'clojure-mode)
(straight-use-package 'cider)
#+END_SRC

* Other config and elisp
** Split and follow
does what it says on the tin.
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
#+END_SRC
Bind these new functions to override the old ones
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Delete frame and buffer
Taken from [[https://emacs.stackexchange.com/questions/2888/kill-buffer-when-frame-is-deleted][here]]
#+BEGIN_SRC emacs-lisp
(defun maybe-delete-frame-buffer (frame)
  "When a dedicated FRAME is deleted, also kill its buffer.
  A dedicated frame contains a single window whose buffer is not
  displayed anywhere else."
  (let ((windows (window-list frame)))
    (when (eq 1 (length windows))
      (let ((buffer (window-buffer (car windows))))
        (when (eq 1 (length (get-buffer-window-list buffer nil t)))
          (kill-buffer buffer))))))
(add-hook 'delete-frame-functions #'maybe-delete-frame-buffer)
#+END_SRC

** Custom keybinds
*** C-o for execute extended
M-x sometimes isn’t recognized on the terminal
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-o") 'execute-extended-command)
#+END_SRC

*** Two keybinds for ace-window switching
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-\;") 'ace-window)
#+END_SRC

*** Kill both buffer and window keybinding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-buffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer-and-window)
#+END_SRC

*** Xref find definition
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h C-f") (lambda ()
                                  (interactive)
                                  (if (> (count-windows) 1)
                                      (xref-find-definitions-other-window
                                       (thing-at-point 'symbol t))
                                    (xref-find-definitions
                                     (thing-at-point 'symbol t)))))

(global-set-key (kbd "C-h C-j") 'xref-pop-marker-stack)
#+END_SRC

** Function to reload init
I make too many changes to type this out every time.
#+BEGIN_SRC emacs-lisp
(defun load-init ()
  (interactive)
  (load-file (expand-file-name "init.el" user-emacs-directory)))
#+END_SRC

** Kill other buffers
#+BEGIN_SRC emacs-lisp
(defun kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

** Spaces over tabs
I don’t like tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Final newline
#+BEGIN_SRC emacs-lisp
(setq mode-require-final-newline nil)
#+END_SRC

** Comment keybinding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c /") 'comment-or-uncomment-region)
#+END_SRC

** Aggressive indenting
#+BEGIN_SRC emacs-lisp
(straight-use-package 'aggressive-indent-mode)
(global-aggressive-indent-mode 1)


(add-to-list
 'aggressive-indent-dont-indent-if
 '(and (derived-mode-p 'c++-mode)
       (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                           (thing-at-point 'line)))))

#+END_SRC

